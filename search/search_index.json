{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"general/networking/","title":"Networking","text":"<p>Networking concepts</p>"},{"location":"low-level-design/","title":"Low Level Design","text":"<p>Low-Level Design (LLD) is the detailed design process in the software development process that focuses on the implementation of individual components described in the High-Level Design.</p>"},{"location":"low-level-design/design-patterns/creational/abstract-factory/","title":"Abstract Factory","text":"<p>The Abstract Factory design pattern allows for the production of families of related objects without specifying their concrete classes. </p>"},{"location":"low-level-design/design-patterns/creational/abstract-factory/#structure","title":"Structure","text":"<p>Below is an example of the abstract factory structure</p> <p>Abstract Factory Structure UML</p> <p> </p> <ul> <li>Abstract Products: abstract class which represents the distinct types of a product.</li> <li>Concrete Products: various implementations of the abstract products.</li> <li>Abstract Factory: interface which declares the method used to create the various products.</li> <li>Concrete Factory: implementation of the creation method. Each of these concrete factory corresponds to a set (or family) of concrete products.</li> </ul>"},{"location":"low-level-design/design-patterns/creational/abstract-factory/#abstract-factory-example","title":"Abstract Factory Example","text":"<p>Imagine a program that simulates two computer component manufacturers that produce monitors and GPUs only. </p> <ul> <li>Two companies: ASUS and MSI</li> <li>Components (or products) they produce: Monitors and GPUs</li> </ul> <p>This is a good example of when to use the abstract factory design patterns since there are two different sets (or family) of products. </p> <ul> <li>Set 1 = ASUS, Set 2 = MSI</li> <li>Products = monitors &amp; GPUs</li> </ul>"},{"location":"low-level-design/design-patterns/creational/abstract-factory/#non-abstract-factory-example","title":"Non Abstract Factory Example","text":"Non Abstract Factory Example C# Example Code<pre><code>// Product (Abstract Class)\npublic abstract class Gpu\n{\n    public abstract void Assemble();\n}\n\n// Product (Abstract Class)\npublic abstract class Monitor\n{\n    public abstract void Assemble();\n}\n\n\n// Product (Concrete Class)\npublic class AsusGpu : Gpu\n{\n    public override void Assemble()\n    {\n        Console.WriteLine(\"Assembling ASUS GPU\");\n    }\n}\n\n// Product (Concrete Class)\npublic class AsusMonitor : Monitor\n{\n    public override void Assemble()\n    {\n        Console.WriteLine(\"Assembling ASUS Monitor\");\n    }\n}\n\n// Product (Concrete Class)\npublic class MsiGpu : Gpu\n{\n    public override void Assemble()\n    {\n        Console.WriteLine(\"Assembling MSI GPU\");\n    }\n}\n\n// Product (Concrete Class)\npublic class MsiMonitor : Monitor\n{\n    public override void Assemble()\n    {\n        Console.WriteLine(\"Assembling MSI Monitor\");\n    }\n}\n\npublic class AsusManufacturer \n{\n    public Gpu CreateGpu()\n    {\n        return new AsusGpu();\n    }\n\n    public Monitor CreateMonitor()\n    {\n        return new AsusMonitor();        \n    }\n}\n\npublic class MsiManufacturer\n{\n    public Gpu CreateGpu()\n    {\n        return new MsiGpu();\n    }\n\n    public Monitor CreateMonitor()\n    {\n        return new MsiMonitor();\n    }\n}\n</code></pre> Driver Code<pre><code>static void Main(string[] args)\n{\n    var desiredCompany = \"MSI\";\n\n    if (desiredCompany == \"ASUS\")\n    {\n        AsusManufacturer asus = new AsusManufacturer();\n        asus.CreateGpu();\n        asus.CreateMonitor();\n    }\n    else if (desiredCompany == \"MSI\")\n    {\n        MsiManufacturer msi = new MsiManufacturer();\n        msi.CreateGpu();\n        msi.CreateMonitor();\n    }\n    else\n    {\n        throw new Exception(\"Invalid Company\");\n    }\n}\n</code></pre> Output<pre><code>Assembling MSI GPU\nAssembling MSI Monitor \n</code></pre> <p>This implementation uses a design pattern similar to the factory pattern (not to be confused with the factory method pattern). </p> <ul> <li><code>AsusManufacturer</code> is a factory that contains methods to create ASUS products (GPU and Monitor)</li> <li><code>MsiManufacturer</code> is a factory that contains methods to create MSI products (GPU and Monitor)</li> </ul> <p>The issue with this implementation can be seen in the driver code. The code expects either a <code>AsusManufacturer</code> or <code>MsiManufacturer</code> object. Lets say the client code gets expanded with more behaviors that is dependent on the manufacturer classes, that code would need to continue to handle both type of manufacturer classes. </p> <p>This issue becomes bigger when a new manufacturer type gets introduce. All the extended behavior would need to be updated again to handle a third manufacturer.</p> <p>This implementation breaks the following SOLID principles: </p> <ul> <li>Single responsibility principle: New reason to change = client code would now need to be updated if adding new family of products</li> <li>Open-Closed principle: Adding a new family of products will break all client code</li> </ul>"},{"location":"low-level-design/design-patterns/creational/abstract-factory/#abstract-factory-example_1","title":"Abstract Factory Example","text":"Abstract Factory Example C# Example Code<pre><code>// Abstract Factory (Abstract Class)\npublic abstract class Company\n{\n    public abstract Gpu CreateGpu();\n    public abstract Monitor CreateMonitor();\n}\n\n// Product (Abstract Class)\npublic abstract class Gpu\n{\n    public abstract void Assemble();\n}\n\n// Product (Abstract Class)\npublic abstract class Monitor \n{\n    public abstract void Assemble();\n}\n\n// Factory (Concrete Class) \npublic class AsusManufacturer : Company\n{\n    public override Gpu CreateGpu()\n    {\n        return new AsusGpu();\n    }\n\n    public override Monitor CreateMonitor()\n    {\n        return new AsusMonitor();        \n    }\n}\n\n// Factory (Concrete Class)\npublic class MsiManufacturer : Company\n{\n    public override Gpu CreateGpu()\n    {\n        return new MsiGpu();\n    }\n\n    public override Monitor CreateMonitor()\n    {\n        return new MsiMonitor();\n    }\n}\n\n// Product (Concrete Class)\npublic class AsusGpu : Gpu\n{\n    public override void Assemble()\n    {\n        Console.WriteLine(\"Assembling ASUS GPU\");\n    }\n}\n\n// Product (Concrete Class)\npublic class AsusMonitor : Monitor \n{\n    public override void Assemble()\n    {\n        Console.WriteLine(\"Assembling ASUS Monitor\");\n    }\n}\n\n// Product (Concrete Class)\npublic class MsiGpu : Gpu\n{\n    public override void Assemble()\n    {\n        Console.WriteLine(\"Assembling MSI GPU\");\n    }\n}\n\n// Product (Concrete Class)\npublic class MsiMonitor : Monitor \n{\n    public override void Assemble()\n    {\n        Console.WriteLine(\"Assembling MSI Monitor\");\n    }\n}\n</code></pre> Driver Code<pre><code>static void Main(string[] args)\n{\n    var desiredCompany = \"MSI\";\n    Company company;\n\n    if (desiredCompany == \"ASUS\")\n    {\n        company = new AsusManufacturer();\n\n    }\n    else if (desiredCompany == \"MSI\")\n    {\n        company = new MsiManufacturer();\n    }\n    else\n    {\n        throw new Exception(\"Invalid Company\");\n    }\n\n    company.CreateGpu();\n    company.CreateMonitor();\n}\n</code></pre> Output<pre><code>Assembling MSI GPU\nAssembling MSI Monitor\n</code></pre> <p>This example introduces the abstract factory <code>Company</code> which acts as the interface to build a family of products. </p> <p>The <code>AsusManufacturer</code> and <code>MsiManufacturer</code> classes are subclasses of the abstract factory and handles creating the respective set of products. </p> <p>In the driver code on line 20-21, either manufacturer subclass can be assigned to the <code>company</code> variable without breaking the rest of the code. This is due to the abstract factory. The abstract factory ensures that each implementation has all the methods the rest of the code expects to see. </p> <p>This implementation fixes the following SOLID principles: </p> <ul> <li>Single responsibility principle: new family of products can be added but it won't break the driver code</li> <li>Open-Closed principle: family of products can be swapped without breaking (line 20-21 in driver code)</li> </ul>"},{"location":"low-level-design/design-patterns/creational/abstract-factory/#when-to-use","title":"When To Use","text":"<ul> <li>Usually, most people will start with a factory method</li> <li>Use when code needs to work with various families of related product, but you don't want it to depend on the concrete classes of those products (might be unknown beforehand or simply want to allow for further extensibility)</li> <li>When you have a set of factory methods, abstract factory might help reorganize all of your factories</li> </ul>"},{"location":"low-level-design/design-patterns/creational/abstract-factory/#resources","title":"Resources","text":"<p> Abstract Factory Example</p> <p> Abstract Factory</p>"},{"location":"low-level-design/design-patterns/creational/builder/","title":"Builder","text":"<p>The Builder design patterns allow for the construction of complex objects step by step. It allows for producing different types and representation of an object using the same construction code.</p> <p>The separation between the construction of a complex object and its representation allows for the construction process to be reused for different representations. </p>"},{"location":"low-level-design/design-patterns/creational/builder/#structure","title":"Structure","text":"<p>Below is an example of a simple builder structure</p> <p>Simple Builder Structure UML</p> <p> </p> <ul> <li>Builder Interface: defines common product construction that is shared between all types of builder (default settings) </li> <li>Products: object which represents some sort of product.</li> <li>Concrete Builders: object that constructs the instance of a product and contains method to set all the fields.</li> </ul> <p>Below is an example of a builder structure</p> <p>Builder Structure UML</p> <p> </p> <ul> <li>Builder Interface: (see simple builder above) </li> <li>Products: (see simple builder above)</li> <li>Concrete Builders: (see simple builder above)</li> <li>Director: defines the order in which to call construction steps. Basically contains presets of certain products to create.</li> </ul>"},{"location":"low-level-design/design-patterns/creational/builder/#builder-example","title":"Builder Example","text":"<p>Imagine a program that constructs two different products: </p> <ol> <li>Car: object that represents a physical car</li> <li>Car Schema: object that represents a schema linked to a car</li> </ol> <p>Both of these products have the follow fields: </p> <ul> <li>Model (string)</li> <li>Engine (string)</li> <li>Seats (int)</li> <li>Color (string)</li> <li>Spoiler (string) </li> </ul> <p>Below are three implementations for this car example.</p> <ol> <li>Non Builder Example</li> <li>Simple Builder Example</li> <li>Builder Example</li> </ol>"},{"location":"low-level-design/design-patterns/creational/builder/#non-builder-example","title":"Non Builder Example","text":"Non Builder Example C# Example Code<pre><code>public class Car\n{\n    public string model;\n    public string engine;\n    public int seats;\n    public string color;\n    public string spoiler;\n\n    public Car(string model, string engine, int seats, string color, string spoiler)\n    {\n        this.model = model;\n        this.engine = engine;\n        this.seats = seats;\n        this.color = color;\n        this.spoiler = spoiler;\n    }\n\n    public override string ToString()\n    {\n        return string.Format(\"Model: {0}, Engine: {1}, Seats: {2}, Color: {3}, Spoiler: {4}\", \n            model, engine, seats, color, spoiler);\n    }\n\n\n    // ... Additional car related behavior ...\n}\n\npublic class CarSchema\n{\n    public string model;\n    public string engine;\n    public int seats;\n    public string color;\n    public string spoiler;\n\n    public CarSchema(string model, string engine, int seats, string color, string spoiler)\n    {\n        this.model = model;\n        this.engine = engine;\n        this.seats = seats;\n        this.color = color;\n        this.spoiler = spoiler;\n    }\n\n    public override string ToString()\n    {\n        return string.Format(\"Model: {0}, Engine: {1}, Seats: {2}, Color: {3}, Spoiler: {4}\", \n            model, engine, seats, color, spoiler);\n    }\n\n    // ... Additional car schema related behavior ...\n}\n</code></pre> Driver Code<pre><code>static void Main(string[] args)\n{\n    Car toyotaTacoma1 = new Car(\"Tacoma\", \"4 Cylinder\", 4, \"Tan\", \"\");\n    Console.WriteLine(toyotaTacoma1);\n\n    CarSchema toyotaTacoma2 = new CarSchema(\"Tacoma\", \"4 Cylinder\", 4, \"Green\", \"\");\n    Console.WriteLine(toyotaTacoma2);\n\n    CarSchema hondaS2000 = new CarSchema(\"S2000\", \"Inline 4 Cylinder Turbo-charged\", 2, \"Yellow\", \"Carbon Fiber\");\n    Console.WriteLine(hondaS2000);\n}\n</code></pre> Output<pre><code>Model: Tacoma, Engine: 4 Cylinder, Seats: 4, Color: Tan, Spoiler:\nModel: Tacoma, Engine: 4 Cylinder, Seats: 4, Color: Green, Spoiler:\nModel: S2000, Engine: Inline 4 Cylinder Turbo-charged, Seats: 2, Color: Yellow, Spoiler: Carbon Fiber\n</code></pre> <p>In this implementation there are two types of objects that are created <code>Car</code> and <code>CarSchema</code>. </p> <p>In the driver code, three instances were made out of these two classes. They are the following: </p> <ul> <li>Tan Toyota Tacoma</li> <li>Green Toyota Tacoma</li> <li>Yellow Honda S2000</li> </ul> <p>On lines 3 and 6 of the driver code, both these lines are initializing Toyota Tacoma's. They both require an empty value for <code>Spoiler</code> since the <code>Car</code> and <code>CarSchema</code> class expects one. This is the main issue that the builder design pattern addresses. </p> <p>Assume the rest of the program builds on top of the Toyota Tacoma objects. If a new car, Semi-Truck, were added and it required a new field called <code>CargoBox</code>. This would require refactoring any code that uses the <code>Car</code>class to pass in this new <code>CargoBox</code> field. </p> <p>This breaks the following SOLID principles: </p> <ul> <li>Single responsibility principle: new reason to refactor = updates to construction of an object (ex. adding a new field)</li> </ul>"},{"location":"low-level-design/design-patterns/creational/builder/#simple-builder-example","title":"Simple Builder Example","text":"Simple Builder Example C# Example Code<pre><code>// Builder (Interface)\npublic interface Builder\n{\n    public Builder AddModel(string model);\n    public Builder AddEngine(string engine);\n    public Builder AddSeats(int seats);\n    public Builder AddColor(string color);\n    public Builder AddSpoiler(string material);\n}\n\n\n// Product (Concrete Class)\npublic class Car\n{\n    public string Model { get; set; }\n    public string Engine { get; set; }\n    public int Seats { get; set; }\n    public string Color { get; set; }\n    public string Spoiler { get; set; }\n    public override string ToString()\n    {\n        return string.Format(\"Model: {0}, Engine: {1}, Seats: {2}, Color: {3}, Spoiler: {4}\", \n            Model, Engine, Seats, Color, Spoiler);\n    }\n\n\n    // ... Additional car related behavior ...\n}\n\n// Product (Concrete Class)\npublic class CarSchema\n{\n    public string Model { get; set; }\n    public string Engine { get; set; }\n    public int Seats { get; set; }\n    public string Color { get; set; }\n    public string Spoiler { get; set; }\n\n    public override string ToString()\n    {\n        return string.Format(\"Model: {0}, Engine: {1}, Seats: {2}, Color: {3}, Spoiler: {4}\", \n            Model, Engine, Seats, Color, Spoiler);\n    }\n\n    // ... Additional car schema related behavior ...\n}\n\n// Builder (Concrete Class)\npublic class CarBuilder : Builder\n{\n    private Car _car = new Car();\n\n    public Builder AddColor(string color)\n    {\n        _car.Color = color;\n        return this;\n    }\n\n    public Builder AddEngine(string engine)\n    {\n        _car.Engine = engine;\n        return this;\n    }\n\n    public Builder AddModel(string model)\n    {\n        _car.Model = model;\n        return this;\n    }\n\n    public Builder AddSeats(int seats)\n    {\n        _car.Seats = seats;\n        return this;\n    }\n\n    public Builder AddSpoiler(string material)\n    {\n        _car.Spoiler = material;\n        return this;\n    }\n\n    public Car Build()\n    {\n        return _car;\n    }\n}\n\n// Builder (Concrete Class)\npublic class CarSchemaBuilder : Builder\n{\n    private CarSchema _carSchema = new CarSchema();\n\n    public Builder AddColor(string color)\n    {\n        _carSchema.Color = color;\n        return this;\n    }\n\n    public Builder AddEngine(string engine)\n    {\n        _carSchema.Engine = engine;\n        return this;\n    }\n\n    public Builder AddModel(string model)\n    {\n        _carSchema.Model = model;\n        return this;\n    }\n\n    public Builder AddSeats(int seats)\n    {\n        _carSchema.Seats = seats;\n        return this;\n    }\n\n    public Builder AddSpoiler(string material)\n    {\n        _carSchema.Spoiler = material;\n        return this;\n    }\n\n    public CarSchema Build()\n    {\n        return _carSchema;\n    }\n}\n</code></pre> Driver Code<pre><code>static void Main(string[] args)\n{\n    CarBuilder carMaker = new CarBuilder();\n    CarSchemaBuilder carSchemaMaker = new CarSchemaBuilder();\n\n    // Building a Toyota Tacoma Car\n    carMaker.AddModel(\"Tacoma\")\n        .AddEngine(\"4 Cylinder\")\n        .AddColor(\"Tan\")\n        .AddSeats(4);\n    Console.WriteLine(carMaker.Build());\n\n    // Building a Toyota Tacoma Car Schema\n    carSchemaMaker.AddModel(\"Tacoma\")\n        .AddEngine(\"4 Cylinder\")\n        .AddColor(\"Green\")\n        .AddSeats(4);\n    Console.WriteLine(carSchemaMaker.Build());\n\n    // Building a S2000 Car Schema\n    carSchemaMaker.AddModel(\"S2000\")\n        .AddEngine(\"Inline 4 Cylinder Turbo-charged\")\n        .AddColor(\"Yellow\")\n        .AddSeats(2)\n        .AddSpoiler(\"Carbon Fiber\");\n    Console.WriteLine(carSchemaMaker.Build());\n\n}\n</code></pre> Output<pre><code>Model: Tacoma, Engine: 4 Cylinder, Seats: 4, Color: Tan, Spoiler:\nModel: Tacoma, Engine: 4 Cylinder, Seats: 4, Color: Green, Spoiler:\nModel: S2000, Engine: Inline 4 Cylinder Turbo-charged, Seats: 2, Color: Yellow, Spoiler: Carbon Fiber\n</code></pre> <p>In this example the <code>Car</code> and <code>CarSchema</code> class now doesn't expect any initial properties/constructor, instead all properties are defined after the instantiation of the class. </p> <p>The <code>Builder</code> interface lets the program know what fields will be expected by the <code>Car</code> and <code>CarSchema</code> class. The actual builders <code>CarBuilder</code> and <code>CarSchemaBuilder</code> handles the construction of the <code>Car</code> and <code>CarSchema</code> classes. </p> <p>Using the same scenario in the bad example, what if a new car, Semi-Truck, was added with the new field <code>CargoBox</code>? </p> <ul> <li>All the classes would need to be updated to handle the new field.  </li> <li>The code in the driver code would remain the same without any issues.</li> </ul> <p>The addition of this simple builder design pattern allows for construction of the products to be separated. Meaning if construction changes (new fields are added), it doesn't effect products already created (the <code>Car</code> and <code>CarSchema</code> objects created in driver code).</p> <p>This fixes the issue that broke the following SOLID principle: </p> <ul> <li>Single responsibility principle: new fields won't break the code since construction logic is separated.</li> </ul> <p>This pattern can be further optimized. The driver code has a lot of duplicated logic which can be cut down by creating a <code>Director</code> class.</p>"},{"location":"low-level-design/design-patterns/creational/builder/#builder-example_1","title":"Builder Example","text":"Builder Example C# Example Code<pre><code>// Builder (Interface)\npublic interface Builder\n{\n    public Builder AddModel(string model);\n    public Builder AddEngine(string engine);\n    public Builder AddSeats(int seats);\n    public Builder AddColor(string color);\n    public Builder AddSpoiler(string material);\n}\n\n\n// Product (Concrete Class)\npublic class Car\n{\n    public string Model { get; set; }\n    public string Engine { get; set; }\n    public int Seats { get; set; }\n    public string Color { get; set; }\n    public string Spoiler { get; set; }\n    public override string ToString()\n    {\n        return string.Format(\"Model: {0}, Engine: {1}, Seats: {2}, Color: {3}, Spoiler: {4}\", \n            Model, Engine, Seats, Color, Spoiler);\n    }\n\n\n    // ... Additional car related behavior ...\n}\n\n// Product (Concrete Class)\npublic class CarSchema\n{\n    public string Model { get; set; }\n    public string Engine { get; set; }\n    public int Seats { get; set; }\n    public string Color { get; set; }\n    public string Spoiler { get; set; }\n\n    public override string ToString()\n    {\n        return string.Format(\"Model: {0}, Engine: {1}, Seats: {2}, Color: {3}, Spoiler: {4}\", \n            Model, Engine, Seats, Color, Spoiler);\n    }\n\n    // ... Additional car schema related behavior ...\n}\n\n// Builder (Concrete Class)\npublic class CarBuilder : Builder\n{\n    private Car _car = new Car();\n\n    public Builder AddColor(string color)\n    {\n        _car.Color = color;\n        return this;\n    }\n\n    public Builder AddEngine(string engine)\n    {\n        _car.Engine = engine;\n        return this;\n    }\n\n    public Builder AddModel(string model)\n    {\n        _car.Model = model;\n        return this;\n    }\n\n    public Builder AddSeats(int seats)\n    {\n        _car.Seats = seats;\n        return this;\n    }\n\n    public Builder AddSpoiler(string material)\n    {\n        _car.Spoiler = material;\n        return this;\n    }\n\n    public Car Build()\n    {\n        return _car;\n    }\n}\n\n// Builder (Concrete Class)\npublic class CarSchemaBuilder : Builder\n{\n    private CarSchema _carSchema = new CarSchema();\n\n    public Builder AddColor(string color)\n    {\n        _carSchema.Color = color;\n        return this;\n    }\n\n    public Builder AddEngine(string engine)\n    {\n        _carSchema.Engine = engine;\n        return this;\n    }\n\n    public Builder AddModel(string model)\n    {\n        _carSchema.Model = model;\n        return this;\n    }\n\n    public Builder AddSeats(int seats)\n    {\n        _carSchema.Seats = seats;\n        return this;\n    }\n\n    public Builder AddSpoiler(string material)\n    {\n        _carSchema.Spoiler = material;\n        return this;\n    }\n\n    public CarSchema Build()\n    {\n        return _carSchema;\n    }\n}\n\n// Director \npublic class Director\n{\n    public void BuildToyotaTacoma(Builder builder)\n    {\n        builder.AddModel(\"Tacoma\")\n            .AddEngine(\"4 Cylinder\")\n            .AddColor(\"Tan\")\n            .AddSeats(4);\n    }\n\n    public void BuildHondaS2000(Builder builder)\n    {\n        builder.AddModel(\"S2000\")\n            .AddEngine(\"Inline 4 Cylinder\")\n            .AddColor(\"Yellow\")\n            .AddSeats(2)\n            .AddSpoiler(\"Carbon Fiber\");\n    }\n}\n</code></pre> Driver Code<pre><code>static void Main(string[] args)\n{\n    Director director = new Director();\n    CarBuilder carMaker = new CarBuilder();\n    CarSchemaBuilder carSchemaMaker = new CarSchemaBuilder();\n\n    // Car builder example - Tacoma\n    director.BuildToyotaTacoma(carMaker);\n    Console.WriteLine(carMaker.Build());\n\n    // Car Schema builder example - Tacoma\n    director.BuildToyotaTacoma(carSchemaMaker);\n    carMaker.AddColor(\"Green\");\n    Console.WriteLine(carSchemaMaker.Build());\n\n    // Car Schema builder example - S2000\n    director.BuildHondaS2000(carSchemaMaker);\n    carSchemaMaker.AddEngine(\"Inline 4 Cylinder Turbo-charged\");\n    Console.WriteLine(carSchemaMaker.Build());\n}\n</code></pre> Output<pre><code>Model: Tacoma, Engine: 4 Cylinder, Seats: 4, Color: Tan, Spoiler:\nModel: Tacoma, Engine: 4 Cylinder, Seats: 4, Color: Green, Spoiler:\nModel: S2000, Engine: Inline 4 Cylinder Turbo-charged, Seats: 2, Color: Yellow, Spoiler: Carbon Fiber\n</code></pre> <p>This implementation is identical to the simple builder example except for the <code>Director</code> class which simplifies the construction process even more. </p> <p>Construction is now simplified by using the methods in the addition of the <code>Director</code> class which creates presets of <code>Car</code> and <code>CarSchema</code> objects.</p>"},{"location":"low-level-design/design-patterns/creational/builder/#when-to-use","title":"When To Use","text":"<ul> <li>When the code needs to represent an object and various representations of that object where the details are slightly different between each representation.</li> <li>Especially useful when there are a lot of variations to create, but the variations share some core behaviors.</li> </ul>"},{"location":"low-level-design/design-patterns/creational/builder/#resources","title":"Resources","text":"<p> Builder Example</p> <p> Builder</p>"},{"location":"low-level-design/design-patterns/creational/factory-method/","title":"Factory Method","text":"<p>The Factory Method design pattern defines an interface for creating object, but lets subclasses decide which class to instantiate. This pattern lets a class defer instantiation to subclasses.</p>"},{"location":"low-level-design/design-patterns/creational/factory-method/#structure","title":"Structure","text":"<p>Below is an example of the structure of a factory method design pattern. </p> <p>Factory Method Structure UML</p> <p> </p> <ul> <li> <p>Creator: class that contains the factory method and any other optional additional operations. The role of the <code>Creator</code> class is not solely product creation, it has other operations that related to the product as well. </p> <ul> <li>Factory Method: method that creates the subclasses, the return type should be the Product interface. This can be set to <code>abstract</code> so subclasses implement their own versions of the method, or it can return some sort of default.</li> </ul> </li> <li> <p>Product: interface that declares all the common properties between objects that can be produced by the <code>Creator</code></p> </li> <li> <p>Concrete Creator: these are the subclass objects that overrides the <code>factory method</code> to have its own object construction.</p> </li> <li> <p>Concrete Product: specific implementations of product interface</p> </li> </ul>"},{"location":"low-level-design/design-patterns/creational/factory-method/#factory-method-example","title":"Factory Method Example","text":"<p>Imagine a program that simulates going out to eat at a restaurant. </p> <p>In the following examples there are two meal preferences: </p> <ul> <li>Italian meal</li> <li>Chinese meal</li> </ul> <p>The program also has a <code>Restaurant</code> class that will prepare a meal based on the type of preference.</p>"},{"location":"low-level-design/design-patterns/creational/factory-method/#non-factory-method-example","title":"Non Factory Method Example","text":"Non Factory Method Example C# Example Code<pre><code>public class ItalianMeal \n{\n    public void Cook()\n    {\n        Console.WriteLine(\"Preparing a delizioso Italian meal\");\n    }\n}\n\npublic class ChineseMeal\n{\n    public void Cook()\n    {\n        Console.WriteLine(\"Preparing a succulent Chinese meal\");\n    }\n}\n\npublic class Restaurant\n{\n    public void OrderMeal(string mealPreference)\n    { \n        if (mealPreference == \"Chinese\")\n        {\n            ChineseMeal chineseMeal = new ChineseMeal();\n            chineseMeal.Cook();\n        }\n        else if (mealPreference == \"Italian\")\n        {\n            ItalianMeal italianMeal = new ItalianMeal();\n            italianMeal.Cook();\n        }\n        else\n        {\n            throw new Exception(\"Invalid meal preference\");\n        }\n    }\n\n    // Additional Business Logic...\n}\n</code></pre> Driver Code<pre><code>static void Main(string[] args)\n{ \n    // var mealPreference = \"Italian\";\n    var mealPreference = \"Chinese\";\n    Restaurant restaurant = new Restaurant();\n    restaurant.OrderMeal(mealPreference);\n}\n</code></pre> Output<pre><code>Preparing a delizioso Italian meal\nPreparing a succulent Chinese meal\n</code></pre> <p>Thl main issue with this implementation is the <code>OrderMeal</code> function in lines 19-35. Every time the restaurant needs to perform a task (such as cooking the meal), it must first know what type of meal (<code>ItalianMeal</code> or <code>ChineseMeal</code>) its dealing with. This causes a tight coupling between various meals and the <code>Restaurant</code> class since adding new meals or changes to the meals constructors require updating the <code>Restaurant</code> class. </p> <p>This implementation breaks the following SOLID principles:</p> <ul> <li>Single Responsibility Principle: <code>Restaurant</code> class has two reasons to be modified now: new meal classes being added and business logic updates to <code>Restaurant</code> class</li> <li>Open-Closed Principle: if new meal classes are added, the <code>Restaurant</code> class needs to be modified. </li> <li>Dependency Inversion Principle: the <code>Restaurant</code> class depends on the <code>ChineseMeal</code> and <code>ItalianMeal</code> class.</li> </ul>"},{"location":"low-level-design/design-patterns/creational/factory-method/#factory-method-example_1","title":"Factory Method Example","text":"Factory Method Example C# Example Code<pre><code>// Creator (Interface)\npublic interface Restaurant\n{\n    // Factory Method\n    public abstract Meal CreateMeal();\n\n    public void OrderMeal()\n    {\n        Meal meal = CreateMeal();\n        meal.Cook();\n    }\n\n    // Additional Business Logic...\n}\n\n// Product (Interface)\npublic interface Meal\n{\n    public void Cook();\n}\n\n// Creator (Concrete Class)\npublic class ItalianRestaurant : Restaurant\n{\n    public Meal CreateMeal()\n    {\n        return new ItalianMeal();\n    }\n}\n\n// Creator (Concrete Class)\npublic class ChineseRestaurant : Restaurant\n{\n    public Meal CreateMeal()\n    {\n        return new ChineseMeal();\n    }\n}\n\n// Product (Concrete Class)\npublic class ItalianMeal : Meal\n{\n    public void Cook()\n    {\n        Console.WriteLine(\"Preparing a delizioso Italian meal\");\n    }\n}\n\n// Product (Concrete Class)\npublic class ChineseMeal : Meal\n{\n    public void Cook()\n    {\n        Console.WriteLine(\"Preparing a succulent Chinese meal\");\n    }\n}\n</code></pre> Driver Code<pre><code>static void Main(string[] args)\n{\n    // var mealPreference = \"Italian\";\n    var mealPreference = \"Chinese\";\n\n    Restaurant restaurant;\n\n    if (mealPreference == \"Chinese\")\n    {\n        restaurant = new ChineseRestaurant();\n    }\n    else if (mealPreference == \"Italian\")\n    {\n        restaurant = new ItalianRestaurant();\n    }\n    else\n    {\n        throw new Exception(\"Invalid meal preference\");\n    }\n\n    restaurant.OrderMeal();\n}\n</code></pre> Output<pre><code>Preparing a delizioso Italian meal\nPreparing a succulent Chinese meal\n</code></pre> <p>This example introduces a slight amount of complexity with interfaces to abstract the <code>Restaurant</code> class and the various <code>Meal</code> classes. </p> <p>The <code>Restaurant</code> class (Creator) now has a factory method to handle creation of <code>Meal</code> subclasses (Products).</p> <p>As seen on line 21 of the driver code, it does not matter whether the <code>restaurant</code> variable (line 6) is defined with a <code>ChineseRestaurant</code> or <code>ItalianRestaurant</code> class, both will not break the rest of the code. This is because both subclasses inherit from the <code>Restaurant</code> class.</p> <p>With this implementation we've fixed issues that broke the following SOLID principles: </p> <ul> <li>Single responsibility principle: if new meals need to be added, none of the classes need to be modified. Instead, all that needs to be done is to create a new <code>Restaurant</code> subclass and a new <code>Meal</code> subclass. </li> <li>Open-Closed principle: same as single responsibility principle</li> <li>Dependency Inversion: the factory method moved the creation of meals to the concrete <code>Restaurant</code> classes.</li> </ul>"},{"location":"low-level-design/design-patterns/creational/factory-method/#when-to-use","title":"When To Use","text":"<ul> <li>When you don't know beforehand the exact Products or types of the objects your code should work with. </li> <li>When you want to provide users a way to extend its internal components</li> </ul>"},{"location":"low-level-design/design-patterns/creational/factory-method/#resources","title":"Resources","text":"<p> Factory Method Example</p> <p> Factory Method</p>"},{"location":"low-level-design/design-patterns/creational/prototype/","title":"Prototype","text":"<p>The prototype design patterns allow for copying existing objects without making the code dependent on the classes. </p>"},{"location":"low-level-design/design-patterns/creational/prototype/#structure","title":"Structure","text":"<p>Below is an example of the structure of a prototype design pattern. </p> <p>Prototype Structure UML</p> <p> </p> <ul> <li>Prototype: interface or abstract class that declares cloning method </li> <li>Concrete Prototype: class that implements cloning method. This is a normal class, but contains function that handles cloning of itself.</li> <li>Subclass Prototype: all children of the concrete prototype also implement cloning. This can be expanded to multiple children. </li> </ul> <p>Prototype Structure + Prototype Registry UML</p> <p> </p> <ul> <li>Prototype: (see prototype structure above)</li> <li>Concrete Prototype: (see prototype structure above)</li> <li>Subclass Prototype: (see prototype structure above)</li> <li>Prototype Registry: A cache that stores frequently used prototypes. Contains method to retrieve from cache, the retrieval method returns a clone copy.</li> </ul>"},{"location":"low-level-design/design-patterns/creational/prototype/#prototype-example","title":"Prototype Example","text":"<p>Imagine a program that creates two animals: </p> <ol> <li>Dogs</li> <li>Turtles</li> </ol> <p>This program should be able to create <code>Dogs</code> and <code>Turtles</code> and also deep copy them.</p> <p>Below are three implementations of this program: </p> <ol> <li>Non Prototype Example </li> <li>Prototype Example</li> <li>Prototype + Registry Example</li> </ol>"},{"location":"low-level-design/design-patterns/creational/prototype/#non-prototype-example","title":"Non Prototype Example","text":"Non Prototype Example C# Example Code<pre><code>public class Dog \n{\n    private string name;\n    private string sex;\n    private string breed;\n\n    public Dog(string name, string sex, string breed) \n    {\n        this.name = name;\n        this.sex = sex;\n        this.breed = breed;\n    }\n\n    private Dog(Dog dog)\n    {\n        this.name = dog.name;\n        this.sex = dog.sex;\n        this.breed = dog.breed;\n    }\n\n    public Dog Clone()\n    {\n        return new Dog(this);\n    }\n}\n\npublic class Turtle\n{\n    private string name;\n    private string sex;\n    private bool isNinja;\n\n    public Turtle(string name, string sex, bool isNinja)\n    {\n        this.name = name;\n        this.sex = sex;\n        this.isNinja = isNinja;\n    }\n\n    private Turtle(Turtle turtle)\n    {\n        this.name = turtle.name;\n        this.sex = turtle.sex;\n        this.isNinja = turtle.isNinja;\n    }\n\n    public Turtle Clone()\n    {\n        return new Turtle(this);\n    }\n}\n</code></pre> Driver Code<pre><code>static void Main(string[] args)\n{ \n    Dog dog = new Dog(\"Alfred\", \"Male\", \"Husky\");\n    Turtle turtle = new Turtle(\"Donatello\", \"Male\", true);\n\n    Dog dogClone = dog.Clone();\n    Turtle turtleClone = turtle.Clone();\n\n    Console.WriteLine(dogClone);\n    Console.WriteLine(turtleClone);\n}\n</code></pre> Output<pre><code>Dog\nTurtle\n</code></pre> <p>In this example a <code>Dog</code> and <code>Turtle</code> object is created on lines 3 and 4 of the driver code. </p> <p>In lines 6 and 7 of the driver code a clone of each of the objects are created. </p> <p>This is a valid implementation that creates clones. The issue is the type of the object must be known before the clones can be created. For example on line 6, it must be known that the object is an instance of <code>Dog</code> before the <code>Clone</code> method can be called. </p> <p>This implementation contains a tight coupling between the object type and the cloning process. </p>"},{"location":"low-level-design/design-patterns/creational/prototype/#prototype-example_1","title":"Prototype Example","text":"Prototype Example C# Example Code<pre><code>// Prototype (Abstract Class)\npublic abstract class Animal\n{\n    public string name;\n    private string sex;\n\n    public Animal(string name, string sex)\n    { \n        this.name = name;\n        this.sex = sex;\n    }\n\n    protected Animal(Animal animal)\n    {\n        this.name = animal.name;\n        this.sex = animal.sex;\n    }\n\n    public abstract Animal Clone();\n}\n\n// Prototype (Subclass)\npublic class Dog : Animal\n{\n    private string breed;\n\n    public Dog(string name, string sex, string breed) : base(name, sex)\n    {\n        this.breed = breed;\n    }\n\n    private Dog(Dog dog) : base(dog)\n    {\n        this.breed = dog.breed;\n    }\n\n    public override Dog Clone()\n    {\n        return new Dog(this);\n    }\n}\n\n// Prototype (Subclass)\npublic class Turtle : Animal\n{\n    private bool isNinja;\n\n    public Turtle(string name, string sex, bool isNinja) : base(name, sex)\n    {\n        this.isNinja = isNinja;\n    }\n\n    private Turtle(Turtle turtle) : base(turtle)\n    {\n        this.isNinja = turtle.isNinja;\n    }\n\n    public override Turtle Clone()\n    {\n        return new Turtle(this);\n    }\n}\n</code></pre> Driver Code<pre><code>static void Main(string[] args)\n{\n    // Create list of animals\n    List&lt;Animal&gt; animalList = new List&lt;Animal&gt;();\n    animalList.Add(new Dog(\"Alfred\", \"Male\", \"Husky\"));\n    animalList.Add(new Turtle(\"Donatello\", \"Male\", true));\n\n    // Create copy of each animal in animalList\n    List&lt;Animal&gt; copyList = new List&lt;Animal&gt;();\n    foreach (Animal animal in animalList)\n    {\n        copyList.Add(animal.Clone());\n    }\n\n    // Print copied animals\n    copyList.ForEach(animal =&gt; { Console.WriteLine(animal); });\n}\n</code></pre> Output<pre><code>Dog\nTurtle\n</code></pre> <p>In this implementation the prototype abstract class <code>Animal</code> declares a <code>Clone</code> method which will handle cloning for the two concrete prototypes <code>Dog</code> and <code>Turtle</code>.</p> <p>On line 12 of the driver code, all the different <code>Animal</code> objects are cloned irrespectively of their actual type (<code>Dog</code> vs <code>Turtle</code>). </p> <p>This implementation decouples the coupling between object types and the cloning process thanks to the prototype abstract class. </p>"},{"location":"low-level-design/design-patterns/creational/prototype/#prototype-registry-example","title":"Prototype + Registry Example","text":"Prototype + Registry Example C# Example Code<pre><code>// Prototype (Abstract Class)\npublic abstract class Animal\n{\n    public string name;\n    private string sex;\n\n    public Animal(string name, string sex)\n    { \n        this.name = name;\n        this.sex = sex;\n    }\n\n    protected Animal(Animal animal)\n    {\n        this.name = animal.name;\n        this.sex = animal.sex;\n    }\n\n    public abstract Animal Clone();\n}\n\n// Prototype (Subclass)\npublic class Dog : Animal\n{\n    private string breed;\n\n    public Dog(string name, string sex, string breed) : base(name, sex)\n    {\n        this.breed = breed;\n    }\n\n    private Dog(Dog dog) : base(dog)\n    {\n        this.breed = dog.breed;\n    }\n\n    public override Dog Clone()\n    {\n        return new Dog(this);\n    }\n}\n\n// Prototype (Subclass)\npublic class Turtle : Animal\n{\n    private bool isNinja;\n\n    public Turtle(string name, string sex, bool isNinja) : base(name, sex)\n    {\n        this.isNinja = isNinja;\n    }\n\n    private Turtle(Turtle turtle) : base(turtle)\n    {\n        this.isNinja = turtle.isNinja;\n    }\n\n    public override Turtle Clone()\n    {\n        return new Turtle(this);\n    }\n}\n\n// Prototype Registry (Class)\npublic class AnimalCache\n{\n    private Dictionary&lt;string, Animal&gt; cache = new Dictionary&lt;string, Animal&gt;();\n\n    public Animal Get(string key)\n    {\n        return cache[key].Clone();\n    }\n\n    public void Put(List&lt;Animal&gt; animals)\n    {\n        animals.ForEach(animal =&gt;\n        {\n            cache.Add(animal.name, animal.Clone());\n        });\n    }\n}\n</code></pre> Driver Code<pre><code>static void Main(string[] args)\n{\n    // Create list of animals\n    List&lt;Animal&gt; animalList = new List&lt;Animal&gt;();\n    animalList.Add(new Dog(\"Alfred\", \"Male\", \"Husky\"));\n    animalList.Add(new Turtle(\"Donatello\", \"Male\", true));\n\n    // Add animalList to registry \n    AnimalCache registry = new AnimalCache();\n    registry.Put(animalList);\n\n    // Pull animals out of registry (these are copied animals)\n    Console.WriteLine(registry.Get(\"Alfred\"));\n    Console.WriteLine(registry.Get(\"Donatello\"));\n}\n</code></pre> <p>This implementation is identical to the previous example except for the addition of the <code>AnimalCache</code> prototype registry class. </p> <p>This class store frequently deep copied objects into a cache. Whenever a copy needs to be pulled, the <code>AnimalCache</code> will automatically create a clone and return it for the user.</p>"},{"location":"low-level-design/design-patterns/creational/prototype/#when-to-use","title":"When To Use","text":"<ul> <li>When code shouldn't depend on the concrete classes of objects needed to be copied.</li> <li>Note: prototype implementation with a deep copy behaves very closely to an abstract/factory method. If the goal of the code is to create completely new copies (instances and all) of an object, an abstract factory might be better.</li> </ul>"},{"location":"low-level-design/design-patterns/creational/prototype/#resources","title":"Resources","text":"<p> Prototype Method Example</p> <p> Prototype</p>"},{"location":"low-level-design/design-patterns/creational/singleton/","title":"Singleton","text":"<p>The singleton design pattern ensures a class has only one instance, while providing a global access point to this instance. Singleton patterns are so common sometimes something could be called a singleton without fulfilling its two functionality (so important it'll be listed again)</p> <ol> <li>Ensure a class has just a single instance</li> <li>Provide global access point to that instance</li> </ol>"},{"location":"low-level-design/design-patterns/creational/singleton/#structure","title":"Structure","text":"<p>Below is an example of the singleton structure</p> <p>Singleton Structure UML</p> <p> </p> <ul> <li>Singleton Class: the singleton class (which will fulfill the two functionalities)<ul> <li>Access Point Method: access point to the single instance</li> </ul> </li> </ul>"},{"location":"low-level-design/design-patterns/creational/singleton/#singleton-example","title":"Singleton Example","text":"<p>Below is an example of a program implementing a database connection pool. To control access to the database, there should only be one connection pool that is being used. This is a perfect example of when to use the singleton design pattern as it will guarantee one connection pool is established, and a way to access this pool.</p>"},{"location":"low-level-design/design-patterns/creational/singleton/#non-singleton-example","title":"Non Singleton Example","text":"Non Singleton example C# Example Code<pre><code>public class DatabaseConnectorPool\n{\n    public DatabaseConnectorPool()\n    {\n        ConnectToDatabases();\n    }\n\n    public void ConnectToDatabases() // Example business logic\n    { \n        // ... Code to setup multiple connections to database\n    }\n\n    public void Query() // Example business logic \n    { \n        // ... Code to pick a database connection and perform query\n    }\n}\n</code></pre> Driver Code<pre><code>static void Main(string[] args)\n{\n    DatabaseConnectorPool pool1 = new DatabaseConnectorPool();\n    pool1.Query();\n\n    DatabaseConnectorPool pool2 = new DatabaseConnectorPool();\n    pool2.Query();\n}\n</code></pre> Output<pre><code>Setting up connection pool\nUsing connection pool to query\nSetting up connection pool\nUsing connection pool to query\n</code></pre> <p>In this example, there are two <code>DatabaseConnectorPool</code> instances (<code>pool1</code> and <code>pool2</code>) as seen in the driver code. </p> <p>In a real world scenario this would mean two connection pools have been created to the database which is a waste of resources, or if the database doesn't handle concurrent reads/writes well, it could cause errors down the line.</p>"},{"location":"low-level-design/design-patterns/creational/singleton/#singleton-example_1","title":"Singleton Example","text":"Singleton example Example Code<pre><code>public sealed class DatabaseConnectorPool // Sealed so no subclasses can be made\n{\n    private static DatabaseConnectorPool _instance;\n\n    // Hidden Constructor\n    private DatabaseConnectorPool()\n    { \n        ConnectToDatabases();\n    }\n\n    // Access Point Method\n    public static DatabaseConnectorPool GetInstance()\n    {\n        if (_instance == null)\n        { \n            _instance = new DatabaseConnectorPool();\n        }\n        return _instance;\n    }\n\n    public void ConnectToDatabases() // Example business logic\n    { \n        Console.WriteLine(\"Setting up connection pool\");\n        // ... Code to setup multiple connections to database\n    }\n\n    public void Query() // Example business logic \n    { \n        Console.WriteLine(\"Using connection pool to query\");\n        // ... Code to pick a database connection and perform query\n    }\n}\n</code></pre> Driver Code<pre><code>static void Main(string[] args)\n{\n    DatabaseConnectorPool pool1 = DatabaseConnectorPool.GetInstance();\n    pool1.Query();\n\n    DatabaseConnectorPool pool2 = DatabaseConnectorPool.GetInstance();\n    pool2.Query();\n}\n</code></pre> Output<pre><code>Setting up connection pool\nUsing connection pool to query\nUsing connection pool to query\n</code></pre> <p>In this example, using the the singleton pattern, the first call of <code>GetInstance</code> creates a new <code>DatabaseConnectorPool</code> instance and assigns it to the <code>_instance</code> variable. All subsequent calls to the <code>GetInstance</code> method will now reference this same instance.</p> <p>The <code>DatabaseConnectorPool</code> class is also set with the <code>sealed</code> keyword to ensure it cannot be inherited.</p> <p>In the output, \"Setting up connection pool\" only printed once which indicates the pool was setup only once and there is in fact only one instance.</p>"},{"location":"low-level-design/design-patterns/creational/singleton/#when-to-use","title":"When To Use","text":"<ul> <li>When an object needs to have a single instance that is available to all clients.</li> </ul>"},{"location":"low-level-design/design-patterns/creational/singleton/#resources","title":"Resources","text":"<p> Singleton</p>"},{"location":"low-level-design/design-patterns/structural/adapter/","title":"Adapter","text":"<p>The Adapter is a design pattern that allows object with incompatible interfaces to collaborate. This adapter bridges between two classes that would normally not be able to communicate with one another. </p> <p>Sometimes the Adapter design pattern is also known as a wrapper design pattern since it wraps the incompatible interface/class to make it interact with the compatible version. </p>"},{"location":"low-level-design/design-patterns/structural/adapter/#implementations","title":"Implementations","text":"<p>There are several implementations of the adapter design pattern that varies based on programming language and context.</p> <ol> <li> <p>Object adapter (composition based)</p> <ul> <li>Adapter holds an instance of the service or adaptee and implements the client or target interface. </li> <li>More flexible as it allows a single adapter to work with multiple *services or adaptees </li> <li>Widely used in language like C# or Java</li> </ul> </li> <li> <p>Class adapter (inheritance based)</p> <ul> <li>Adapter class inherits from both the client or target interface and the service or adaptee. </li> <li>Programming languages that allow multiple inheritance (C++) are more likely to use this technique</li> </ul> </li> </ol>"},{"location":"low-level-design/design-patterns/structural/adapter/#structure","title":"Structure","text":"<p>Below is an example of the object adapter structure</p> <p>Adapter (Object) Structure UML</p> <p> </p> <ul> <li>Client: class that contains existing business logic.</li> <li>Client Interface or Target Interface: defines the interface expected by the client. It declares the methods the client can use.</li> <li>Service or Adaptee: some useful class/object that is incompatible with client code (usually 3rd-party service or legacy code)</li> <li>Adapter: class that implements/inherits the client interface AND wraps the service class. It receives calls from the client and translates it for the wrapper service object to understand. </li> </ul>"},{"location":"low-level-design/design-patterns/structural/adapter/#adapter-example","title":"Adapter Example","text":"<p>Consider a scenario where there is a program that displays weather information based on the current location data. The program generates weather data in XML format and the weather service API takes in XML data and returns the corresponding weather information. </p> <p>A new weather service is now available and the code should be updated to use this new service. The issue is this new service only takes in JSON data for the location data. Additionally, the service is a third party service and the source code can not be edited. </p> <p>The adapter design pattern helps bridge the gap with communicating with this incompatible new service. </p> <p>A quick break down of this example. There are two services (legacy vs modern) that both expects two different location data types (XML vs JSON)</p> <ul> <li>Legacy Service: XML data</li> <li>Modern Service: JSON data</li> </ul>"},{"location":"low-level-design/design-patterns/structural/adapter/#non-adapter-example","title":"Non Adapter Example","text":"Non Adapter Example C# Example Code<pre><code>public class XmlData { }\npublic class JsonData { }\n\npublic interface ILegacyWeatherService\n{\n    public void GetCurrentWeather(XmlData location);\n    public void GetWeekForecast(XmlData location);\n}\n\npublic class LegacyWeatherService : ILegacyWeatherService\n{\n    public void GetCurrentWeather(XmlData location)\n    {\n        Console.WriteLine(\"Using XML Data to get current weather data...\");\n    }\n\n    public void GetWeekForecast(XmlData location)\n    {\n        Console.WriteLine(\"Using XML Data to get forecast for the week...\");\n    }\n}\n\npublic class ModernWeatherService\n{ \n    public void GetCurrentWeather(JsonData location)\n    {\n        Console.WriteLine(\"Using JSON Data to get current weather data...\"); }\n\n    public void GetWeekForecast(JsonData location)\n    {\n        Console.WriteLine(\"Using JSON Data to get forecast for the week...\");\n    }\n\n}\n</code></pre> Driver Code<pre><code>public static JsonData ConvertXmlToJson(XmlData location)\n{\n    Console.WriteLine(\"Converting XML data to JSON\");\n    return new JsonData();\n}\n\nstatic void Main(string[] args)\n{ \n    XmlData geoLocation = new XmlData();\n\n    // LegacyWeatherService service = new LegacyWeatherService();\n    // service.GetCurrentWeather(geoLocation);\n    // service.GetWeekForecase(geoLocation);\n\n    ModernWeatherService service = new ModernWeatherService();\n    JsonData geoLocationJSON = ConvertXmlToJson(geoLocation);\n    service.GetCurrentWeather(geoLocationJSON);\n    service.GetWeekForecast(geoLocationJSON);\n}\n</code></pre> Output<pre><code>Converting XML data to JSON\nUsing JSON Data to get current weather data...\nUsing JSON Data to get forecast for the week...\n</code></pre> <p>In this example, the adapter design pattern was not use. Instead, a new method <code>ConvertXmlToJson</code> was added to handle converting the <code>XmlData</code> location data to the <code>JsonData</code> format. </p> <p>This implementation required going into the client code and modifying all instances of the <code>XmlData</code> location data and converting it to the new data type. </p> <p>This violates the following SOLID principles: </p> <ul> <li>Single responsibility principle: the client code had to be refactored to introduce conversion code</li> <li>Open-closed principle: switching between <code>ModernWeatherService</code> and <code>LegacyWeatherService</code> does not work without changing client code first</li> </ul>"},{"location":"low-level-design/design-patterns/structural/adapter/#adapter-example_1","title":"Adapter Example","text":"Adapter Example C# Example Code<pre><code>public class XmlData { }\npublic class JsonData { }\n\n// Client Interface or Target Interface (Interface)\npublic interface ILegacyWeatherService\n{\n    public void GetCurrentWeather(XmlData location);\n    public void GetWeekForecast(XmlData location);\n}\n\n// Client (Class)\npublic class LegacyWeatherService : ILegacyWeatherService\n{\n    public void GetCurrentWeather(XmlData location)\n    {\n        Console.WriteLine(\"Using XML Data to get current weather data...\");\n    }\n\n    public void GetWeekForecast(XmlData location)\n    {\n        Console.WriteLine(\"Using XML Data to get forecast for the week...\");\n    }\n}\n\n// Service or Adaptee (Class)\npublic class ModernWeatherService\n{ \n    public void GetCurrentWeather(JsonData location)\n    {\n        Console.WriteLine(\"Using JSON Data to get current weather data...\"); }\n\n    public void GetWeekForecast(JsonData location)\n    {\n        Console.WriteLine(\"Using JSON Data to get forecast for the week...\");\n    }\n\n}\n\n// Adapter (Class)\npublic class ModernWeatherServiceAdapter : ILegacyWeatherService\n{\n    private ModernWeatherService modernWeatherService;\n\n    public ModernWeatherServiceAdapter() \n    {\n        modernWeatherService = new ModernWeatherService(); \n    }\n\n    public void GetCurrentWeather(XmlData location)\n    {\n        JsonData jsonData = ConvertXmlToJson(location);\n        modernWeatherService.GetCurrentWeather(jsonData);\n    }\n\n    public void GetWeekForecast(XmlData location)\n    {\n        JsonData jsonData = ConvertXmlToJson(location);\n        modernWeatherService.GetWeekForecast(jsonData);\n    }\n\n    private JsonData ConvertXmlToJson(XmlData location)\n    {\n        Console.WriteLine(\"Converting XML data to JSON\");\n        return new JsonData();\n    }\n}\n</code></pre> Driver Code<pre><code>static void Main(string[] args)\n{\n    XmlData geoLocation = new XmlData();\n\n    // LegacyWeatherService service = new LegacyWeatherService();\n    ModernWeatherServiceAdapter service = new ModernWeatherServiceAdapter();\n\n    service.GetCurrentWeather(geoLocation);\n    service.GetWeekForecast(geoLocation);\n}\n</code></pre> Output<pre><code>Converting XML data to JSON\nUsing JSON Data to get current weather data...\nConverting XML data to JSON\nUsing JSON Data to get forecast for the week...\n</code></pre> <p>In this example the object adapter was introduce (line 36-62) which automatically handles conversion between the two data types. The adapter also inherited from the <code>ILegacyWeatherService</code> interface which guarantees that the behavior between the Legacy service and the Modern service will be the same. </p> <p>As seen on line 5 and 6 of the driver code, the two services can be used interchangeably without causing issues to the rest of the client code. </p> <p>This addresses the two SOLID principles that were broken before: </p> <ul> <li>Single responsibility principle: client code now can remain the same (only need to change which service is desired).</li> <li>Open-closed principle: the Legacy and Modern service can be used interchangeably.</li> </ul>"},{"location":"low-level-design/design-patterns/structural/adapter/#when-to-use","title":"When To use","text":"<ul> <li>When connecting systems or components that weren't built to work together</li> <li>When existing code or libraries don't match the current system</li> </ul>"},{"location":"low-level-design/design-patterns/structural/adapter/#resources","title":"Resources","text":"<p> Adapter</p> <p> Adapter</p>"},{"location":"low-level-design/design-patterns/structural/bridge/","title":"Bridge","text":"<p>The bridge design pattern allows for large classes or sets of closely related classes to be split into two separate hierarchies - abstraction and implementation - which can be developed independently of each other.</p> <ul> <li>Both the abstraction and implementation can be an interface or an abstract class. </li> <li>This pattern decouples the relationship between the abstraction and implementation. </li> </ul>"},{"location":"low-level-design/design-patterns/structural/bridge/#structure","title":"Structure","text":"<p>Below is an example of the bridge structure</p> <p>Bridge (Object) Structure UML</p> <p> </p> <ul> <li>Abstraction: high level control logic. Relies on implementation for the actual low level work.</li> <li>Implementation: Declares interface common to all concrete implementations. An abstraction can only communicate with the implementation objects through the methods declared here. </li> <li>Refined Abstraction: Extends abstraction and adds more details on how code interacts with concrete implementation.</li> <li>Concrete Implementation: Actual code for the implementation </li> </ul>"},{"location":"low-level-design/design-patterns/structural/bridge/#bridge-example","title":"Bridge Example","text":"<p>Consider a program that represented the following shapes that come in a variety of colors: </p> <ul> <li>There are two shapes (Rectangle and Triangle)</li> <li>There are two colors (Red and Blue)</li> </ul> <p>Below is an example of designing this program with and without the bridge pattern. </p>"},{"location":"low-level-design/design-patterns/structural/bridge/#non-bridge-example","title":"Non Bridge Example","text":"Non Bridge Example C# Example Code<pre><code>public interface Shape\n{\n    public void CreateShape();\n}\n\npublic interface Rectangle : Shape\n{\n    public void MakeForm();\n}\n\npublic interface Triangle : Shape\n{\n    public void MakeForm();\n}\n\npublic class RedRectangle : Rectangle\n{\n    public void CreateShape()\n    {\n        Console.Write(\"Creating \");\n        MakeColor();\n        MakeForm();\n        Console.WriteLine(\"\");\n    }\n\n    public void MakeColor()\n    {\n        Console.Write(\"Red \");\n    }\n\n    public void MakeForm()\n    {\n        Console.Write(\"Rectangle\");\n    }\n}\n\npublic class BlueRectangle : Rectangle\n{\n    public void CreateShape()\n    {\n        Console.Write(\"Creating \");\n        MakeColor();\n        MakeForm();\n        Console.WriteLine(\"\");\n    }\n\n    public void MakeColor()\n    {\n        Console.Write(\"Blue \");\n    }\n\n    public void MakeForm()\n    {\n        Console.Write(\"Rectangle\");\n    }\n}\n\npublic class RedTriangle : Triangle\n{\n    public void CreateShape()\n    {\n        Console.Write(\"Creating \");\n        MakeColor();\n        MakeForm();\n        Console.WriteLine(\"\");\n    }\n\n    public void MakeColor()\n    {\n        Console.Write(\"Red \");\n    }\n\n    public void MakeForm()\n    {\n        Console.Write(\"Triangle\");\n    }\n}\n\npublic class BlueTriangle : Triangle\n{\n    public void CreateShape()\n    {\n        Console.Write(\"Creating \");\n        MakeColor();\n        MakeForm();\n        Console.WriteLine(\"\");\n    }\n\n    public void MakeColor()\n    {\n        Console.Write(\"Blue \");\n    }\n\n    public void MakeForm()\n    {\n        Console.Write(\"Triangle\");\n    }\n}\n</code></pre> Driver Code<pre><code>static void Main(string[] args)\n{\n    Shape shape1 = new RedRectangle();\n    Shape shape2 = new BlueTriangle();\n\n    shape1.CreateShape();\n    shape2.CreateShape();\n}\n</code></pre> Output<pre><code>Creating Red Rectangle\nCreating Blue Triangle\n</code></pre> <p>In this implementation the classes are in a hierarchical structure. This is a working example of the program as all four permutations of the shapes can be created (Red rectangle, blue rectangle, and red triangle blue triangle).</p> <p>The issue with this implementation is if the <code>Rectangle</code> class needed to be updated this could effect both the <code>RedRectangle</code> and <code>BlueRectangle</code> subclasses. </p> <p>Additionally, if changes were made to the colors then both the <code>Rectangle</code> and <code>Triangle</code> classes may be effected.</p> <p>This is due to the hierarchy structure causing all the classes to be tightly coupled to one another. </p> <p>This breaks the following SOLID principles: </p> <ul> <li>Single responsibility principle: changes to the <code>Rectangle</code> and <code>Triangle</code> classes can cascade down to the subclasses</li> </ul>"},{"location":"low-level-design/design-patterns/structural/bridge/#bridge-example_1","title":"Bridge Example","text":"Bridge Example C# Example Code<pre><code>// Abstraction (Abstract Class)\npublic abstract class Shape\n{\n    protected Color color;\n\n    public Shape(Color color)\n    {\n        this.color = color;\n    }\n\n    public abstract void MakeForm();\n\n    public void CreateShape() \n    {\n        Console.Write(\"Creating \");\n        this.color.MakeColor();\n        MakeForm();\n        Console.WriteLine(\"\");\n    }\n}\n\n// Implementation (Interface)\npublic interface Color\n{\n    public void MakeColor();\n}\n\n// Refined Abstraction (Class)\npublic class Rectangle : Shape\n{\n    public Rectangle(Color color) : base(color) { }\n\n    public override void MakeForm()\n    {\n        Console.Write(\"Rectangle\");\n    }\n}\n\n// Refined Abstraction (Class)\npublic class Triangle : Shape\n{\n    public Triangle(Color color) : base(color) { }\n\n    public override void MakeForm()\n    {\n        Console.Write(\"Triangle\");\n    }\n}\n\n// Concrete Implementation (Class)\npublic class Red : Color\n{\n    public void MakeColor()\n    {\n        Console.Write(\"Red \");\n    }\n}\n\n// Concrete Implementation (Class)\npublic class Blue : Color\n{\n    public void MakeColor()\n    {\n        Console.Write(\"Blue \");\n    }\n}\n</code></pre> Driver Code<pre><code>static void Main(string[] args)\n{\n    Shape shape1 = new Rectangle(new Red());\n    Shape shape2 = new Triangle(new Blue());\n\n    shape1.CreateShape();\n    shape2.CreateShape();\n}\n</code></pre> Output<pre><code>Creating Red Rectangle\nCreating Blue Triangle\n</code></pre> <p>This implementation fixes the issues in the last example by introducing the abstraction class <code>Shape</code> and the implementation interface <code>Color</code>. </p> <p>With the implementation and abstraction the form (rectangle and triangle) logic can be separated from the color (red and blue) logic. </p> <p>This also means both of these can easily be extended (new forms and new colors added) without them breaking each other. </p> <p>The following SOLID principles are now fixes from the previous example:</p> <ul> <li>Single responsibility principle: the form and color are now decoupled from one another and won't effect each other. </li> </ul>"},{"location":"low-level-design/design-patterns/structural/bridge/#when-to-use","title":"When To Use","text":"<ul> <li>When the need to subclass many times occur but the relationship is orthogonal with one another (not straight hierarchy but independent separated hierarchies).</li> <li>When composition is preferred over inheritance. </li> <li>When dividing a monolithic class that has several variants of some functionality. <ul> <li>Splitting things into several hierarchies but still having them related</li> </ul> </li> </ul>"},{"location":"low-level-design/design-patterns/structural/bridge/#resources","title":"Resources","text":"<p> Bridge</p> <p> Bridge</p> <p> Bridge</p>"},{"location":"low-level-design/design-patterns/structural/composite/","title":"Composite","text":"<p>The composite design pattern composes objects into a tree structure that can be interacted with as if they are individual objects. </p> <p>The client can interact with this composition of objects uniformly meaning a client can interact with the objects whether its a subtree or a leaf.</p>"},{"location":"low-level-design/design-patterns/structural/composite/#structure","title":"Structure","text":"<p>Below is an example of the composite structure</p> <p>Composite (Object) Structure UML</p> <p> </p> <ul> <li>Component: describe operations that are common to both simple and complex elements of the tree</li> <li>Leaf: basic element of tree that does not have sub-elements. They tend to do most of the real work <ul> <li>Usually does most of the real work as it does not have to deal with delegating actions. </li> </ul> </li> <li>Composite: element that contains sub-elements (leaves or other composites). <ul> <li>On requests, it delegates work to its sub-elements, aggregates the results, and return it back to the client</li> </ul> </li> </ul>"},{"location":"low-level-design/design-patterns/structural/composite/#composite-example","title":"Composite Example","text":"<p>Imagine a program used to track products sold at an amazon factory. The program contains two different types of objects: </p> <ul> <li>Boxes </li> <li>Products</li> </ul> <p>Each box can hold smaller boxes and/or products. The desired behavior for this program is whether a client is interacting with a user or a box, the client should be able to determine the price of all its content (sub-boxes and products).</p> <p>Below is an implementation of this program with using the composite design pattern and without. </p>"},{"location":"low-level-design/design-patterns/structural/composite/#non-composite-example","title":"Non Composite Example","text":"Non Composite Example C# Example Code<pre><code>public class Box\n{\n    public string name { get; set; }\n    private List&lt;Box&gt; boxes;\n    private List&lt;Product&gt; products;\n\n    public Box(List&lt;Box&gt; boxes, List&lt;Product&gt; products, string name)\n    {\n        this.name = name;\n        this.boxes = boxes;\n        this.products = products;\n    }\n\n    public double CalculatePrice()\n    {\n        double total = 0;\n        boxes.ForEach(box =&gt; { total += box.CalculatePrice(); });\n        products.ForEach(product =&gt; { total += product.price; });\n\n        return total;\n    }\n}\n\npublic interface Product \n{\n    public string name { get; set; }\n    public double price { get; set; }\n}\n\npublic class Book : Product\n{\n    public string name { get; set; }\n    public double price { get; set; }\n\n    public Book(string name, double price)\n    {\n        this.name = name;\n        this.price = price;\n    }\n}\n\npublic class VideoGame : Product\n{\n    public string name { get; set; }\n    public double price { get; set; }\n\n    public VideoGame(string name, double price)\n    {\n        this.name = name;\n        this.price = price;\n    }\n}\n</code></pre> Driver Code<pre><code>public static void SetupOrder(Box box)\n{\n    Console.WriteLine(\"Price of {0}: {1}\", box.name, box.CalculatePrice());\n}\n\npublic static void SetupOrder(Product product)\n{\n    Console.WriteLine(\"Price of {0}: {1}\", product.name, product.price);\n}\n\nstatic void Main(string[] args)\n{\n    VideoGame game1 = new VideoGame(\"Pokemon\", 60);\n    VideoGame game2 = new VideoGame(\"Zelda\", 59);\n    VideoGame game3 = new VideoGame(\"Pikmin\", 27);\n    Book book1 = new Book(\"Anathem\", 12);\n    Book book2 = new Book(\"Eragon\", 16);\n\n    // Constructing Small Box\n    List&lt;Box&gt; amazonListMiniBoxList = new List&lt;Box&gt;();\n    List&lt;Product&gt; amazonListMiniProductList = new List&lt;Product&gt;();\n    amazonListMiniProductList.Add(book2);\n    Box amazonListMiniBox = new Box(amazonListMiniBoxList, amazonListMiniProductList, \"Amazon Mini Box\");\n\n    // Constructing Big Box\n    List&lt;Box&gt; amazonBoxBoxList = new List&lt;Box&gt;();\n    amazonBoxBoxList.Add(amazonListMiniBox); // Putting small box into big box\n    List&lt;Product&gt; amazonBoxProductList = new List&lt;Product&gt;();\n    amazonBoxProductList.Add(game1);\n    amazonBoxProductList.Add(game2);\n    amazonBoxProductList.Add(book1);\n    Box amazonBox = new Box(amazonBoxBoxList, amazonBoxProductList, \"Amazon Box\");\n\n    SetupOrder(amazonBox);\n    SetupOrder(game3);\n}\n</code></pre> Output<pre><code>Price of Amazon Box: 147\nPrice of Pikmin: 27\n</code></pre> <p>In this example there are two classes to represent the two type of objects that will be packaged in the amazon factory, <code>Box</code> and <code>Product</code>. </p> <p>The <code>Box</code> class has a <code>boxes</code> field and a <code>products</code> field to represent that both smaller boxes and products can be placed within a box. </p> <p>The problem with this implementation can be seen in the driver code. The client code is tightly coupled with the specific class implementations. This is evident in the two methods in lines 1-4 and 6-9 in the driver code which demonstrates the use of method overloading to handle the two class types. </p> <p>This code also breaks the following SOLID principles: </p> <ul> <li>Open-close principle: introducing a new element type into the app will break the currently existing code. For example what if a box can also contain a tracker. A new class called <code>Tracker</code> would be made but the <code>Box</code> class would have to be refactored to include calculating the price for that as well. </li> </ul>"},{"location":"low-level-design/design-patterns/structural/composite/#composite-example_1","title":"Composite Example","text":"Composite Example C# Example Code<pre><code>// Component (Interface)\npublic interface Box\n{\n    public string name { get; set; }\n\n    public double CalculatePrice();\n}\n\n// Composite (Class)\npublic class CompositeBox : Box\n{\n    public string name { get; set; }  \n    private List&lt;Box&gt; children = new List&lt;Box&gt;();\n\n    public CompositeBox(List&lt;Box&gt; boxes, string name)\n    {\n        this.name = name;\n        children.AddRange(boxes);\n    }\n\n    public double CalculatePrice()\n    {\n        // Handles aggregating prices from sub composite boxes and products\n        double total = 0;\n        children.ForEach(c =&gt; total += c.CalculatePrice());\n        return total;\n    }\n}\n\n// Interface for Leafs (Interface)\npublic interface Product : Box\n{\n    public double price { get; set; }\n}\n\n// Leaf (Class)\npublic class Book : Product\n{\n    public string name { get; set; }\n    public double price { get; set; }\n\n    public Book(string name, double price)\n    {\n        this.name = name;\n        this.price = price;\n    }\n\n    public double CalculatePrice()\n    {\n        return price;\n    }\n}\n\n// Leaf (Class)\npublic class VideoGame : Product\n{\n    public string name { get; set; }\n    public double price { get; set; }\n\n    public VideoGame(string name, double price)\n    {\n        this.name = name;\n        this.price = price;\n    }\n\n    public double CalculatePrice()\n    {\n        return price;\n    }\n}\n</code></pre> Driver Code<pre><code>public static void SetupOrder(Box box)\n{\n    Console.WriteLine(\"Price of {0}: {1}\", box.name, box.CalculatePrice());\n}\n\nstatic void Main(string[] args)\n{\n    // Products\n    VideoGame game1 = new VideoGame(\"Pokemon\", 60);\n    VideoGame game2 = new VideoGame(\"Zelda\", 59);\n    VideoGame game3 = new VideoGame(\"Pikmin\", 27);\n    Book book1 = new Book(\"Anathem\", 12);\n    Book book2 = new Book(\"Eragon\", 16);\n\n    // Constructing Small Box\n    List&lt;Box&gt; amazonListMini = new List&lt;Box&gt;();\n    amazonListMini.Add(book2);\n    Box amazonBoxMini = new CompositeBox(amazonListMini, \"Amazon Mini Box\");\n\n    // Constructing Big Box\n    List&lt;Box&gt; amazonList = new List&lt;Box&gt;();\n    amazonList.Add(game1);\n    amazonList.Add(game2);\n    amazonList.Add(book1);\n    amazonList.Add(amazonBoxMini); // Putting small box into big box\n    Box amazonBox = new CompositeBox(amazonList, \"Amazon Box\");\n\n    SetupOrder(amazonBox);\n    SetupOrder(game3);\n}\n</code></pre> Output<pre><code>Price of Amazon Box: 147\nPrice of Pikmin: 27\n</code></pre> <p>In this example the composite design pattern is used. With the implementation of the <code>Box</code> component, each object (whether its a box or a product) will now be expected to give the name and total price of the object. </p> <p>The <code>CompositeBox</code> still handles aggregating price from sub-boxes and products, but thanks to the <code>Box</code> interface the interaction between the two is now uniformed. </p> <p>This can be seen in the driver code. In the driver code there is a <code>amazonBox</code> object which is a box that contains a nested box and products. When running the <code>SetupOrder</code> method, the method behaves properly whether passing in a single product or a potentially nested box. </p> <p>This solves the issue in the previous example that broke the SOLID principles: </p> <ul> <li>Open-close principle: If the <code>Tracker</code> class is added now, nothing would need to be refactored. It would just need to inherit the <code>Box</code> component.</li> </ul>"},{"location":"low-level-design/design-patterns/structural/composite/#when-to-use","title":"When To Use","text":"<ul> <li>When dealing with objects that naturally fit a tree-like structure</li> <li>When the client needs to interact with simple and complex elements uniformly</li> </ul>"},{"location":"low-level-design/design-patterns/structural/composite/#resources","title":"Resources","text":"<p> Composite</p> <p> Composite - GFG</p> <p> Composite</p>"},{"location":"low-level-design/design-patterns/structural/decorator/","title":"Decorator","text":"<p>The Decorator design pattern attaches new behavior to an object by placing the objects inside special wrapper objects that contain the behaviors. </p> <p>This design pattern is often synonymous with a wrapper. A wrapper is an object that is linked with a target object and it contains the same methods as the target and delegates all the requests it receives. The difference is the wrapper may alter the results either before or after it passes to the target.</p>"},{"location":"low-level-design/design-patterns/structural/decorator/#structure","title":"Structure","text":"<p>Below is an example of the decorator structure</p> <p>Decorator (Object) Structure UML</p> <p> </p> <ul> <li>Component: this declares the common interface used by both wrappers and wrapped objects.</li> <li>Concrete Component: this is the class for the object being wrapped. It defines basic behavior that may be altered by the decorators.</li> <li>Base Decorator: this class acts as the default wrapper<ul> <li>It contains a field of the wrapped object</li> <li>The wrapped object field should be of type Component so it can handle both new decorators and concrete components</li> <li>The decorator delegates operations to the wrapped object</li> </ul> </li> <li>Concrete Decorator: defines extra behaviors that can be added to the components dynamically<ul> <li>Overrides methods in the base decorator and execute its logic before or after calling the parent method</li> </ul> </li> </ul>"},{"location":"low-level-design/design-patterns/structural/decorator/#decorator-example","title":"Decorator Example","text":"<p>Imagine a notifier program that has the ability to send notifications to the following places:</p> <ul> <li>Email (default)</li> <li>Microsoft Teams</li> <li>Slack</li> </ul> <p>The notifier program should be able to send notifications to a single place or to multiple places if desired. </p> <p>Below are two implementations, one utilizing decorator design pattern and one without. </p>"},{"location":"low-level-design/design-patterns/structural/decorator/#non-decorator-example","title":"Non Decorator Example","text":"Non Decorator Example C# Example Code<pre><code>public class Notifier\n{\n\n    private string name;\n\n    public Notifier(string name)\n    {\n        this.name = name;\n    }\n\n    public virtual void SendMessage()\n    { \n        Console.WriteLine(\"Sending notification through Email to {0}\", name);\n    }\n\n    public string GetUser()\n    {\n        return name;\n    }\n}\n\npublic class MicrosoftTeamsNotifier : Notifier\n{\n    public MicrosoftTeamsNotifier(string name) : base(name)\n    {\n    }\n\n    public override void SendMessage()\n    {\n        Console.WriteLine(\"Sending notification through Microsoft Teams to {0}\", base.GetUser());\n    }\n}\npublic class SlackNotifier : Notifier\n{\n    public SlackNotifier(string name) : base(name)\n    {\n    }\n\n    public override void SendMessage()\n    {\n        Console.WriteLine(\"Sending notification through Slack to {0}\", base.GetUser());\n    }\n}\n\npublic class MicrosoftTeamsAndSlackNotifier : Notifier\n{\n    public MicrosoftTeamsAndSlackNotifier(string name) : base(name)\n    {\n    }\n\n    public override void SendMessage()\n    { \n        MicrosoftTeamsNotifier teamsNotifier = new MicrosoftTeamsNotifier(base.GetUser());\n        SlackNotifier slackNotifier = new SlackNotifier(base.GetUser());\n        base.SendMessage();\n        teamsNotifier.SendMessage();\n        slackNotifier.SendMessage();\n    }\n}\n</code></pre> Driver Code<pre><code>static void Main(string[] args)\n{\n    // Single notification (to email)\n    Notifier notifier = new Notifier(\"Jessy\");\n    notifier.SendMessage();\n\n    // Multiple notification (to all)\n    notifier = new MicrosoftTeamsAndSlackNotifier(notifier.GetUser());\n    notifier.SendMessage();\n}\n</code></pre> Output<pre><code>Sending notification through Email to Jessy\n\nSending notification through Email to Jessy\nSending notification through Microsoft Teams to Jessy\nSending notification through Slack to Jessy\n</code></pre> <p>In this example a hierarchy architecture approach was implemented, meaning the default notifier (emails) is the main class and the other two notifiers (Microsft Teams and Slack) are subclasses of the main class. </p> <p>This implementation works fine when signaling one notifier at a time. This can be seen in lines 3-5 in the driver code. </p> <p>The issue with this example is when triggering multiple notifications at once. The class <code>MicrosoftTeamsAndSlackNotifier</code> on lines 45-59 in the example code had to be introduced to handle multiple notifications. If this example contained more notifiers, more of these multi-notifier classes would have to be created which will quickly become difficult to manage. </p> <p>This implementation also breaks the following SOLID principles:</p> <ul> <li>Single responsibility principle: lets say a new method is introduced to the Slack notifier called <code>SaveToLogs</code>. This change would require refactoring the <code>MicrosoftTeamsAndSlackNotifier</code> which breaks the single responsibility principle. </li> </ul>"},{"location":"low-level-design/design-patterns/structural/decorator/#decorator-example_1","title":"Decorator Example","text":"Decorator Example C# Example Code<pre><code>// Component (Interface)\npublic interface INotifier\n{\n    public void SendMessage();\n    public string GetUser();\n}\n\n// Concrete Component (Class) \npublic class Notifier : INotifier\n{\n    private string name;\n\n    public Notifier(string name)\n    {\n        this.name = name;\n    }\n\n    public string GetUser()\n    {\n        return name;\n    }\n\n    // Default behavior is to send alerts by email\n    public void SendMessage()\n    {\n        Console.WriteLine(\"Sending notification through Email to {0}\", name);\n    }\n}\n\n// Base Decorator (Abstract Class)\npublic abstract class BaseNotifierDecorator : INotifier\n{\n    private INotifier wrapped;\n\n    public BaseNotifierDecorator(INotifier wrapped)\n    {\n        this.wrapped = wrapped;\n    }\n\n    public virtual void SendMessage()\n    {\n        wrapped.SendMessage();\n    }\n\n    public virtual string GetUser()\n    {\n        return wrapped.GetUser();\n    }\n}\n\n// Concrete Decorator (Class)\npublic class MicrosoftTeamsDecorator : BaseNotifierDecorator\n{\n    public MicrosoftTeamsDecorator(INotifier wrapped) : base(wrapped)\n    {\n    }\n\n    public override void SendMessage()\n    {\n        base.SendMessage();\n        Console.WriteLine(\"Sending notification through Microsoft Teams to {0}\", base.GetUser());\n    }\n}\n\n// Concrete Decorator (Class)\npublic class SlackDecorator : BaseNotifierDecorator\n{\n    public SlackDecorator(INotifier wrapped) : base(wrapped)\n    {\n    }\n\n    public override void SendMessage()\n    {\n        base.SendMessage();\n        Console.WriteLine(\"Sending notification through Slack to {0}\", base.GetUser());\n    }\n}\n</code></pre> Driver Code<pre><code>public static void Main(string[] args)\n{\n    // Single notification (to email)\n    INotifier notifier = new Notifier(\"Jessy\");\n    notifier.SendMessage();\n\n    // Multiple notification (to all)\n    notifier = new MicrosoftTeamsDecorator(notifier);\n    notifier = new SlackDecorator(notifier);\n    notifier.SendMessage();\n}\n</code></pre> Output<pre><code>Sending notification through Email to Jessy\n\nSending notification through Email to Jessy\nSending notification through Microsoft Teams to Jessy\nSending notification through Slack to Jessy\n</code></pre> <p>In this example the decorator design pattern is utilized. The core of this pattern is the BaseDecorator class <code>BaseNotifierDecorator</code>. This decorator is responsible for triggering the <code>SendMessage</code> method to its wrapped object (which should be the Concrete Component).</p> <p>Since all the decorators utilize the <code>INotifier</code> interface, decorators can be wrapped on top of each other which can be seen on lines 8 and 9 in the driver code. </p> <p>Each of the decorators follow the same pattern for the <code>SendMessage</code> method: </p> <ol> <li>Call the wrapped object's <code>SendMessage</code> </li> <li>Run its custom <code>SendMessage</code> implementation. </li> </ol> <p>As the decorators continued to get wrapped within each other, it triggers a chain of these methods that run in order. </p> <p>This fixes the broken SOLID principles from the last example: </p> <ul> <li>Single responsibility principle: using the same example of introducing the new method <code>SaveToLogs</code> to the Slack notifier, only the <code>SlackDecorator</code> would need to be refactored to integrate these changes, nothing else will be effected.</li> </ul>"},{"location":"low-level-design/design-patterns/structural/decorator/#when-to-use","title":"When To Use","text":"<ul> <li>When the program needs to assign extra behaviors to objects at runtime without breaking code that uses those objects.  </li> <li>When its awkward to extend and object's behavior using inheritance. </li> </ul>"},{"location":"low-level-design/design-patterns/structural/decorator/#resources","title":"Resources","text":"<p> Decorator</p> <p> Decorator</p>"},{"location":"low-level-design/object-oriented-programming/","title":"Object Oriented Programming","text":"<p>Object oriented programming (OOP) is a programming design pattern that utilizes classes/objects to organize code and data.</p> <ul> <li>OOP represents complex things into a structured model</li> <li>Once the OOP model is created, it can reused (reuse code)</li> <li>Allows for better security </li> <li>Allows for easier debugging</li> </ul>"},{"location":"low-level-design/object-oriented-programming/principles/","title":"4 Principles of OOP","text":"<p>There are four pillars to object oriented programming:</p> <ul> <li>Inheritance: child class inherits data and behavior from parent</li> <li>Encapsulation: contain information in an object, exposing only selected information</li> <li>Abstraction: only exposing high-level public methods for accessing an object</li> <li>Polymorphism: many methods can do the same task</li> </ul>"},{"location":"low-level-design/object-oriented-programming/principles/#inheritance","title":"Inheritance","text":"<p>Inheritance: allow classes to inherit features of other classes. This is done by declaring a child class a children of some parent class.</p> <ul> <li><code>children classes</code> have access to functions/properties within <code>parent classes</code></li> <li>This allows the creation of new classes and building of additional functionalities on top of already existing classes. </li> </ul> <p>Benefits: </p> <ul> <li>Provides better code re-usability and organization</li> </ul> Inheritance Example C# Inheritance Example<pre><code>// Base Class\npublic class Bicycle \n{\n    // Fields in bicycle\n    public int gear;\n    public int speed;\n\n    // Constructor\n    public Bicycle(int gear, int speed)\n    {\n        this.gear = gear;\n        this.speed = speed;\n    }\n\n    // Three functions\n    public void ApplyBrake(int decrement)\n    {\n        speed -= decrement;\n    }\n\n    public void SpeedUp(int increment)\n    { \n        speed += increment;\n    }\n\n    // Virtual function that will be overridden\n    public virtual string GetSpecs()\n    {\n        return (\"Gear: \" + gear + \"\\n\"\n                + \"Speed: \" + speed);\n    }\n}\n\n// Derived Class\npublic class RoadBike : Bicycle\n{\n    // One new field\n    public int seatHeight;\n\n    // Constructor\n    public RoadBike(int gear, int speed, int seatHeight) : base(gear, speed)\n    {\n        this.seatHeight = seatHeight;\n    }\n\n    // New function\n    public void SetSeatHeight(int newSeatHeight)\n    {\n        seatHeight = newSeatHeight;\n    }\n\n    // Override virtual function from Bicycle class\n    public override string GetSpecs()\n    { \n        return (\"Gear: \" + gear + \"\\n\"\n                + \"Speed: \" + speed + \"\\n\"\n                + \"Seat Height: \" + seatHeight);\n    }\n}\n\n// Driver code\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Bicycle bike = new Bicycle(3, 0);\n        bike.SpeedUp(25);\n        Console.WriteLine(bike.GetSpecs());\n\n        Console.WriteLine(\"--------\");\n\n        RoadBike trek = new RoadBike(12, 0, 5);\n        trek.SpeedUp(30);\n        trek.SetSeatHeight(7);\n        Console.WriteLine(trek.GetSpecs());\n    }\n}\n</code></pre> Output<pre><code>Gear: 3\nSpeed: 25\n--------\nGear: 12\nSpeed: 30\nSeat Height: 7\n</code></pre> <p>Line 35 shows the <code>RoadBike</code> class which is a derived class of <code>Bicycle</code> which is the base class. </p> <p>All fields and functions in the <code>Bicycle</code> class exists in the <code>RoadBike</code> class. This can be seen on line 73. The <code>RoadBike</code> object \"Trek\" has the <code>SpeedUp</code> function even though it is not in the explicitly defined in the <code>RoadBike</code> class. </p>"},{"location":"low-level-design/object-oriented-programming/principles/#encapsulation","title":"Encapsulation","text":"<p>Encapsulation: keeping all important info within an object revealing only necessary information. This is done by defining fields with access modifiers (public, private, protected, etc...).</p> <ul> <li>Access modifiers can be added onto classes, methods, or properties. It is a keyword which states who can see the code it is attached to. Here are some popular access modifiers:<ul> <li>Public: methods and properties accessible from outside of the class</li> <li>Private: methods and properties accessible from other methods in the same class</li> <li>Protected: methods and properties accessible from derived classes (child classes)</li> </ul> </li> </ul> <p>Benefits:</p> <ul> <li>Provides security (hides important information)</li> <li>Protects against mistakes (hides important functionality, programmers won't invoke something important on accident)</li> </ul> Encapsulation Example C# Encapsulation Example<pre><code>public class BankAccount\n{\n    // Private fields, cannot edit directly\n    private string accountHolder;\n    private decimal balance;\n\n    public BankAccount(string accountHolder, decimal initialBalance)\n    { \n        this.accountHolder = accountHolder;\n        balance = initialBalance;\n    }\n\n    // Property to set/get the balance field\n    public decimal Balance\n    {\n        get { return balance; } // Getter is public\n        private set             // Setter is private\n        {\n            if (value &gt;= 0)     // Only allow non-negative balances\n            {\n                balance = value;\n            }\n            else\n            {\n                Console.WriteLine(\"Balance cannot be negative\");\n            }\n        }\n    }\n\n    // Public function to deposit money and update balance\n    public void Deposit(decimal amount)\n    {\n        if (amount &gt; 0) {\n            Balance += amount;\n            Console.WriteLine($\"Deposited {amount:C}. New Balance is {Balance:C}. \\n\" +\n                $\"Thank you, {accountHolder}.\");\n        }\n        else\n        {\n            Console.WriteLine($\"Deposit amount must be positive.\");\n        }\n    }\n\n    // Public function to withdraw money and update balance\n    public void Withdraw(decimal amount)\n    {\n        if (amount &gt; 0 &amp;&amp; amount &lt;= balance)\n        {\n            Balance -= amount;\n            Console.WriteLine($\"Withdrew {amount:C}. New Balance is {Balance:C}. \\n\" +\n                $\"Thank you, {accountHolder}.\");\n        }\n        else\n        { \n            Console.WriteLine($\"Insufficient funds or invalid withdraw amount\" +\n                $\"You broke, {accountHolder}.\");\n        }\n    }\n\n    // Public function to view account into\n    public void DisplayAccountInfo()\n    {\n        Console.WriteLine($\"Account Holder: {accountHolder}, Balance: {Balance:C}\");\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        // Creating a BankAccount object\n        BankAccount account = new BankAccount(\"John Doe\", 500.00m);\n\n        // Display account information\n        account.DisplayAccountInfo();\n\n        // Performing some transactions\n        account.Deposit(200.00m); // Deposit\n        account.Withdraw(100.00m); // Withdraw\n\n        // account.Balance = 100; // This line would cause a compile-time error\n    }\n}\n</code></pre> Output<pre><code>Account Holder: John Doe, Balance: $500.00\nDeposited $200.00. New Balance is $700.00.\nThank you, John Doe.\nWithdrew $100.00. New Balance is $600.00.\nThank you, John Doe.\n</code></pre> <p>In this example there are two private fields <code>accountHolder</code> and <code>balance</code> in the <code>BankAccount</code> class. The private access modifier protect these fields from being directly manipulated. </p> <p>Instead, there is a <code>Balance</code> property which allows for <code>BankAccount</code> objects to update their own <code>balance</code> field, and lets code outside of that class to retrieve that field.</p> <p>There is also public functions <code>Deposit</code> and <code>Withdraw</code> that can be used outside of the <code>BankAccount</code> object to update the <code>balance</code> field. This is done in line 78 and 79. </p> <p>Line 81 shows an example of an error. This is because it is trying to access the <code>balance</code> field which is set to private. </p>"},{"location":"low-level-design/object-oriented-programming/principles/#abstraction","title":"Abstraction","text":"<p>Abstraction: uses encapsulation to hide complex tasks and present users with more simple functionalities. </p> <ul> <li>This is done also with access modifiers. </li> <li>Abstraction can be implemented by presenting a public function that calls a complex function that is set to private.</li> </ul> <p>Benefits: </p> <ul> <li>Reduces complexity (high-level representation of code)</li> <li>Helps with security (don't want to expose inner workings of a program)</li> </ul> Abstraction Example C# Abstraction Example<pre><code>// Abstract Base Class\npublic abstract class Animal\n{\n    // Abstract function with no implementation\n    public abstract void AnimalSound();\n\n    // Normal function with implementation\n    public void Sleep()\n    {\n        Console.WriteLine(\"zzz\");\n    }\n}\n\n// Derived Class\npublic class Pig : Animal\n{\n    // Defines the abstract function\n    public override void AnimalSound()\n    {\n        Console.WriteLine(\"Oink\");\n    }\n}\npublic class Program\n{\n    static void Main(string[] args)\n    {\n        Pig myPig = new Pig();  // Create a Pig object\n        myPig.AnimalSound();    // Call the abstract method\n        myPig.Sleep();          // Call the regular method\n\n        // Throws an error can't make an instance of an abstract class\n        // Animal test = new Animal();\n    }\n}\n</code></pre> Output<pre><code>Oink\nzzz\n</code></pre> <p>This example shows an abstract class <code>Animal</code> and a class <code>Pig</code> which inherits from the abstract class. An abstract class can't be instantiated on it own, as shown on line 32. </p> <p>An abstract class has an abstract function (line 5). Whenever a class inherits from an abstract class, it will expect the abstract function to be defined. This can be seen in the <code>Pig</code> example on line 18.</p> <p>The regular function <code>Sleep</code> on line 8 displays one of the benefits of abstraction. Lets assume the <code>Animal</code> class needed functions to determine if an animal is healthy. These functions could be complex such as \"GetBloodPressure\", \"CalculateRestingHeartRate\", and \"CalculateAverageLifeExpectancy\". The <code>Pig</code> class could use abstraction by creating a function called <code>IsHealthy</code> and then within that call all the other functions related to health. This makes it so a user interacting with the <code>Pig</code> class would only need to interact with one function instead of all the complicated ones to determine health.</p>"},{"location":"low-level-design/object-oriented-programming/principles/#polymorphism","title":"Polymorphism","text":"<p>Polymorphism: design objects to share behaviors. Using inheritance, objects can override shared behaviors with specific child behaviors. Basically, given one method, there could be multiple ways that function can behave.</p> <ul> <li>Method overriding: child class implements different function than the parent<ul> <li>This is a compile time polymorphism</li> </ul> </li> <li>Method overloading: same method names, but different parameters, thus different behaviors<ul> <li>This is a run time polymorphism</li> </ul> </li> </ul> <p>Benefits: </p> <ul> <li>Allows the use of interface, but adjust individual behavior for individual classes</li> </ul> Polymorphism Example C# Polymorphism Example<pre><code>// Base Class \npublic class Dog \n{\n    // Virtual method that will be overridden\n    public virtual void Bark()\n    {\n        Console.WriteLine(\"Woof Woof\");\n    }\n}\n\npublic class GuardDog : Dog\n{\n    // Method override - new bark command\n    public override void Bark()\n    {\n        Console.WriteLine(\"GRAHHHH\");\n    }\n\n    // Method overload - handles a string input\n    public void Bark(string verbal_command)\n    {\n        Console.WriteLine(\"roo roo, GRAHH GRAHH\");\n    }\n\n    // Method overload - handles a boolean input\n    public void Bark(bool point)\n    {\n        Console.WriteLine(\"roh, WROOF\");\n    }\n}\n\npublic class Program\n{\n    static void Main(string[] args)\n    {\n        Dog Bunson = new Dog();\n        GuardDog Rufus = new GuardDog();\n\n        Bunson.Bark();\n        Rufus.Bark();\n        Rufus.Bark(\"Intruder!\");\n        Rufus.Bark(true);\n    }\n}\n</code></pre> Output<pre><code>Woof Woof\nGRAHHHH\nroo roo, GRAHH GRAHH\nroh, WROOF\n</code></pre> <p>The <code>Bark</code> function on line 14 is an example of method overriding. It is overriding the currently existing function in the <code>Dog</code> class. </p> <p>The <code>Bark</code> function on line 20 and 26 is an example of method overloading. They handle the cases of when the <code>Bark</code> command is called with a boolean or a string input. </p>"},{"location":"low-level-design/object-oriented-programming/structure/","title":"OOP Structure","text":"<p>There are four main components used to create an OOP model</p> <ul> <li>Functions/Methods: code logic to perform a specific task</li> <li>Properties/Attributes: pure data </li> <li>Classes: blueprint of an object</li> <li>Objects: instances of a class</li> </ul>"},{"location":"low-level-design/object-oriented-programming/structure/#functions","title":"Functions","text":"<p>Functions are code-logic that performs some certain task. Here is a list of potential behaviors of a function.</p> <ul> <li>Print something</li> <li>Update a property</li> <li>Perform a task and return some data</li> </ul> Function Example C#Python C# Function Example<pre><code>public void speak()\n{\n    Console.WriteLine(\"Borf Borf\");\n}\n</code></pre> Python Function Example<pre><code>def speak():\n    print('Borf Borf')\n</code></pre> <p>In this example we have a single function called <code>speak</code>. The function prints out \"Borf Borf\" to the console.</p>"},{"location":"low-level-design/object-oriented-programming/structure/#properties","title":"Properties","text":"<p>Properties are data that are stored within an object.</p> Properties Example C#Python C# Properties Example<pre><code>public class Dog                \n{\n    public string name;         // Property\n    public Dog(string name)     // Constructor\n    {\n        this.name = name \n    }\n}\n</code></pre> Python Properties Example<pre><code>class Dog: \n    def __init__(self, name: str):\n        # Creates property called name\n        self.name = name            \n</code></pre> <p>In this example we have a class called <code>Dog</code> with the property <code>name</code>. </p>"},{"location":"low-level-design/object-oriented-programming/structure/#classes","title":"Classes","text":"<p>Classes are user-defined data types. They act as a blueprint of how an object is suppose to look like in terms of the functions and properties it contains. Below is an example of a class.</p> Class Example C#Python C# Class Example<pre><code>public class Dog                \n{\n    public string name;         // Property\n    public Dog(string name)     // Constructor\n    {\n        this.name = name \n    }\n}\n</code></pre> Python Class Example<pre><code>class Dog: \n    def __init__(self, name: str):\n        # Creates property called name\n        self.name = name            \n</code></pre> <p>This example has a class called <code>Dog</code> to represent a dog. </p> <p>The name of the dog is not explicitly stated in the class. This is because classes are a blueprint/model. If we made an object with this class, the name would have to be defined.</p>"},{"location":"low-level-design/object-oriented-programming/structure/#objects","title":"Objects","text":"<p>Objects are instances of a class with specific data. The class provides us with the blueprint and an object will use a class and provide it with actual data. Below is an example of an object.</p> Object Example C#Python C# Class Example<pre><code>public class Dog                \n{\n    public string name;         // Property\n    public Dog(string name)     // Constructor\n    {\n        this.name = name \n    }\n\n    public void speak()\n    {\n        if (this.name == \"Sir Barkington\")\n        {\n            Console.WriteLine(\"BORF BORF\");\n        } else {\n            Console.WriteLine(\"ROOH ROOH\");\n        }\n\n    }\n}\n\nDog puppy1 = Dog(\"Sir Barkington\");\nDog puppy2 = Dog(\"Lady Barkington\");\n\npuppy1.speak()  // Prints BORF BORF\npuppy2.speak()  // Prints ROOH ROOH\n</code></pre> Python Class Example<pre><code>class Dog: \n    def __init__(self, name: str):\n        # Creates property called name\n        self.name = name            \n\n    def speak():\n        if self.name == \"Sir Barkington\"\n            print(\"BORF BORF\")\n        elif self.name == \"Lady Barkington\"\n            print(\"ROOH ROOH\")\n\npuppy1 = Dog('Sir Barkington')\npuppy2 = Dog('Lady Barkington')\n\npuppy1.speak()  # Prints BORF BORF\npuppy2.speak()  # Prints ROOH ROOH\n</code></pre> <p>In this example, the <code>Dog</code> class is used to create two dog objects. Each is a different instance of the class. </p> <p>The <code>puppy1</code> object uses the constructor to create a dog with the name Sir Barkington</p> <p>The <code>puppy2</code> object uses the constructor to create a dog with the name Lady Barkington</p> <p>When the speak method is invoked for these two objects, they will both print out different barks. This is because they are different instances with different <code>name</code> properties.</p>"},{"location":"low-level-design/solid/","title":"SOLID","text":"<p>SOLID is a design principle for object oriented software development. It stands for the following: </p> <ul> <li>Single Responsibility Principle</li> <li>Open-Closed Principle</li> <li>Liskov Substitution Principle</li> <li>Interface Segregation Principle</li> <li>Dependency Inversion</li> </ul>"},{"location":"low-level-design/solid/#single-responsibility-principle","title":"Single Responsibility Principle","text":"<p>Single responsibility principle: a class should have one, and only one, reason to change. Each class should have one sole purpose (responsibility) and not be filled with excessive functionality. </p> <p>Advantages: </p> <ul> <li>More organize</li> <li>If errors occur, they're isolated and smaller</li> </ul>"},{"location":"low-level-design/solid/#open-closed-principle","title":"Open-Closed Principle","text":"<p>Open-closed principle: should be able to extend a class's behavior without modifying it. </p> <ul> <li>Minimize risk of adding something that'll break code</li> <li>Less merge conficts</li> <li>Scalable</li> </ul>"},{"location":"low-level-design/solid/#liskov-substitution-principle","title":"Liskov Substitution Principle","text":"<p>Liskov substitution principle: every derived class should be substitutable for its parent class. </p> <ul> <li>Minimize useless inheritance (some people do it just to reuse code)</li> <li>Integrate new objects faster</li> </ul>"},{"location":"low-level-design/solid/#interface-segregation-principle","title":"Interface Segregation Principle","text":"<p>Interface segregation principle: make fine grained interfaces that are client-specific. Clients should not be forced to implement interfaces they do not use. </p> <ul> <li>Goes with single responsibility (more organized) </li> <li>Not forcing users to implement things they don't need == less code, less problems</li> </ul>"},{"location":"low-level-design/solid/#dependency-inversion-principle","title":"Dependency Inversion Principle","text":"<p>Dependency inversion principle: developers should depend on abstractions, not on concretions. High level modules should not depend upon low level modules. Both should depend on abstractions. Abstractions should not depend on details, details should depend upon abstractions. </p> <ul> <li>Decouples code </li> </ul>"},{"location":"low-level-design/solid/dip/dip/","title":"Dependency Inversion Principle example","text":"<p>Dependency inversion principle: developers should depend on abstractions, not on concretions. High level modules should not depend upon low level modules. Both should depend on abstractions. Abstractions should not depend on details, details should depend upon abstractions. </p> Invalid Example C# Invalid Example<pre><code>public class SalaryCalculator\n{\n    public float CalculateSalary()\n    {\n        // Code to calculate salary\n        return 0;\n    }\n}\n\npublic class EmployeeDetails\n{\n    public int HoursWorked { get; set; }\n    public int HourlyRate { get; set; }\n\n    public float GetSalary()\n    {\n        var salaryCalculator = new SalaryCalculator();\n        return salaryCalculator.CalculateSalary();\n    }\n}\n</code></pre> <p>This breaks the dependency inversion principle since the higher-level class (<code>EmployeeDetails</code>) is dependent on the lower-level class (<code>SalaryCalculator</code>) as seen on line 17-18.</p> Valid Example C# Valid Example<pre><code>public interface ISalaryCalculator\n{\n    float CalculateSalary();\n}\n\npublic class SalaryCalculator : ISalaryCalculator\n{\n    public float CalculateSalary()\n    {\n        // Code to calculate salary\n        return 0;\n    }\n}\n\npublic class EmployeeDetails\n{\n    private readonly ISalaryCalculator _salaryCalculator;\n\n    public int HoursWorked { get; set; }\n    public int HourlyRate { get; set; }\n\n    public EmployeeDetails(ISalaryCalculator salaryCalculator)\n    {\n        _salaryCalculator = salaryCalculator;\n    }\n\n    public float GetSalary()\n    {\n        return _salaryCalculator.CalculateSalary();\n    }\n}\n</code></pre> <p>This adheres to the dependency inversion principle since the <code>ISalaryCalculator</code> interface provide an abstraction for the <code>EmployeeDetails</code> class to reference. </p> <p>This implementation allows the <code>SalaryCalculator</code> to update it's behavior without having to modify the <code>EmployeeDetails</code> class. </p>"},{"location":"low-level-design/solid/isp/isp/","title":"Interface Segregation Principle Example","text":"<p>Interface segregation principle: make fine grained interfaces that are client-specific. Clients should not be forced to implement interfaces they do not use. </p> Invalid Example C# Invalid Example<pre><code>public interface Clock\n{\n    void SetAlarm(DateTime time);\n    float ReadThermometer();\n    void TuneInToRandomRadio();\n}\n\npublic class AncientClock : Clock\n{\n    public void SetAlarm(DateTime time)\n    {\n        // Code to set alarm\n    }\n\n    public float ReadThermometer()\n    {\n        throw new InvalidOperationException(\"Ancient clocks do not have thermometers\");\n    }\n\n    public void TuneInToRandomRadio()\n    {\n        throw new InvalidOperationException(\"Ancient clocks do not have radios\");\n    }\n}\n\npublic class ModernClock : Clock\n{\n    public void SetAlarm(DateTime time)\n    {\n        // Code to set alarm\n    }\n\n    public float ReadThermometer()\n    {\n        // Code to read thermometer and return temp\n        return 0;\n    }\n\n    public void TuneInToRandomRadio()\n    {\n        throw new InvalidOperationException(\"Modern clocks do not have radios\");\n    }\n}\n</code></pre> <p>This breaks the interface segregation example because the functions <code>ReadThermometer</code> and <code>TuneInToRadio</code> in the <code>AncientClock</code> class needed to be defined even though an ancient clock does not have those features. </p> <p>This same example can be seen in the <code>TuneInToRadio</code> function in the <code>ModernClock</code> class as well. </p> Valid Example C# Valid Example<pre><code>public interface Thermometer\n{\n    float ReadThermometer();\n}\n\npublic interface Alarm\n{\n    void SetAlarm(DateTime time);\n}\n\npublic interface RadioPlayer\n{\n    void TuneInToRandomRadio();\n}\n\npublic class AncientClock : Alarm\n{\n    public void SetAlarm(DateTime time)\n    {\n        // Code to set alartm\n    }\n}\n\npublic class ModernClock : Alarm, Thermometer\n{\n    public void SetAlarm(DateTime time)\n    {\n        // Code to set alarm\n    }\n\n    public float ReadThermometer()\n    {\n        // Code to read thermometer and return temp\n        return 0;\n    }\n}\n</code></pre> <p>This example fixes the issues in the invalid interface segregation example. It does this by separating the functions in the <code>Clock</code> interface nto separate interfaces. </p> <p>Now when a derived class like <code>AncientClock</code> or <code>ModernClock</code> needs to inherit these functions they can inherit from the respective interfaces.</p>"},{"location":"low-level-design/solid/lsp/lsp/","title":"Liskov Substitution Principle Example","text":"<p>Liskov substitution principle: every derived class should be substitutable for its parent class. </p> Invalid Example C# Invalid Example<pre><code>// Base class: Bird\npublic class Bird\n{\n    public virtual void Fly()\n    {\n        Console.WriteLine(\"This bird is flying.\");\n    }\n}\n\n// Derived class: Sparrow\npublic class Sparrow : Bird\n{\n    public override void Fly()\n    {\n        Console.WriteLine(\"The sparrow is flying.\");\n    }\n}\n\n// Derived class: Penguin (A bird that can't fly)\npublic class Penguin : Bird\n{\n    public override void Fly()\n    {\n        // Violating Liskov Substitution Principle, as penguins can't fly.\n        throw new InvalidOperationException(\"Penguins cannot fly!\");\n    }\n}\n\npublic class Program\n{\n    public static void MakeBirdFly(Bird bird)\n    {\n        bird.Fly();\n    }\n\n    public static void Main()\n    {\n        Bird sparrow = new Sparrow();\n        Bird penguin = new Penguin();\n\n        MakeBirdFly(sparrow);       // Output: The sparrow is flying.\n\n        try\n        {\n            MakeBirdFly(penguin);  // Output: Exception will be thrown\n        }\n        catch (InvalidOperationException ex)\n        {\n            Console.WriteLine(ex.Message);  // Output: Penguins cannot fly!\n        }\n    }\n}\n</code></pre> <p>This breaks the Liskov substitution principle since there are two derived classes <code>Sparrow</code> and <code>Penguin</code> and they cannot be used interchangeably. On line 41, <code>MakeBirdFly</code> can be called with the <code>sparrow</code> object being passed in without errors. However passing in a <code>penguin</code> object (line 45) will cause errors. </p> Valid Example C# Valid Example<pre><code>// Base class: Bird\npublic class Bird\n{\n    public virtual void Move()\n    {\n        Console.WriteLine(\"This bird is moving\");\n    }\n}\n\n// Derived class: Sparrow (Can fly)\npublic class Sparrow : Bird\n{\n    public override void Move()\n    {\n        Console.WriteLine(\"The sparrow is flying.\");\n    }\n}\n\n// Derived class: Penguin (Cannot fly)\npublic class Penguin : Bird\n{\n    public override void Move()\n    {\n        Console.WriteLine(\"The penguin is swimming.\");\n    }\n}\n\npublic class Program\n{\n    public static void MakeBirdMove(Bird bird)\n    {\n        bird.Move();\n    }\n\n    public static void Main()\n    {\n        Bird sparrow = new Sparrow();\n        Bird penguin = new Penguin();\n\n        MakeBirdMove(sparrow);  // Output: The sparrow is flying.\n        MakeBirdMove(penguin);  // Output: The penguin is swimming.\n    }\n}\n</code></pre> <p>This adheres to the Liskov substitution principle since all birds can move. This means whatever derived class that is created can be swapped into the function calls on line 40 and 41 without ever causing errors. </p>"},{"location":"low-level-design/solid/ocp/ocp/","title":"Open-Closed Principle Example","text":"<p>Open-closed principle: should be able to extend a class's behavior without modifying it. </p> Invalid Example C# Invalid Example<pre><code>public class Order\n{\n    public string CustomerType { get; set; }\n    public double TotalAmount { get; set; }\n\n    // ... \n}\n\npublic class DiscountCalculator\n{\n    /**\n    This breaks open-closed principle because if we need to add more customer \n    type, or need to change discount rates we would need to edit/update this \n    function\n    **/\n    public double CalculateDiscount(Order order)\n    {\n        double discount = 0;\n\n        // Discount logic based on customer type\n        if (order.CustomerType == \"Regular\")\n        {\n            discount = order.TotalAmount * 0.1; // 10% discount for regular customers\n        }\n        else if (order.CustomerType == \"VIP\")\n        {\n            discount = order.TotalAmount * 0.2; // 20% discount for VIP customers\n        }\n        else if (order.CustomerType == \"Employee\")\n        {\n            discount = order.TotalAmount * 0.3; // 30% discount for employees\n        }\n\n        return discount;\n    }\n}\n</code></pre> <p>This breaks the open-closed principle because the <code>DiscountCalculator</code> class cannot be extended to handle more discounts for other customer types without having to refactor the <code>DiscountCalculator</code> class itself. The <code>CalculateDiscount</code> would need to be refactored to add more customer types and corresponding discounts, specifically the if-else statement block on line 21 to 32. </p> Valid Example C# Valid Example<pre><code>public class Order\n{\n    public string CustomerType { get; set; }\n    public double TotalAmount { get; set; }\n\n    // ...\n}\n\npublic interface IDiscountStrategy\n{\n    double CalculateDiscount(Order order);\n}\n\npublic class RegularCustomerDiscount : IDiscountStrategy\n{\n    public double CalculateDiscount(Order order)\n    {\n        return order.TotalAmount * 0.1; // 10% discount for regular customers\n    }\n}\n\npublic class VIPCustomerDiscount : IDiscountStrategy\n{\n    public double CalculateDiscount(Order order)\n    {\n        return order.TotalAmount * 0.2; // 20% discount for VIP customers\n    }\n}\n\npublic class EmployeeDiscount : IDiscountStrategy\n{\n    public double CalculateDiscount(Order order)\n    {\n        return order.TotalAmount * 0.3; // 30% discount for employees\n    }\n}\n\npublic class DiscountCalculator\n{\n    private readonly IDiscountStrategy _discountStrategy;\n\n    /**\n    This now adheres to open-closed principle since the individual changes to \n    order types are handled by the individual discount classes.\n    **/\n    public DiscountCalculator(IDiscountStrategy discountStrategy)\n    {\n        _discountStrategy = discountStrategy;\n    }\n\n    public double CalculateDiscount(Order order)\n    {\n        return _discountStrategy.CalculateDiscount(order);\n    }\n}\n</code></pre> <p>Implementing the <code>IDiscountStrategy</code> interfaces fixes the issues in the invalid example that broke the open-closed principle. </p> <p>Now the different discounts that are needed can be handled with individual classes that inherit from the <code>IDiscountStrategy</code> interface. The <code>DiscountCalculator</code> just needs the strategy to be passed in for it to behave identically to the invalid example. </p> <p>The difference is now that the discounts are separate from the <code>DiscountCalculator</code> class, new discounts can be made without having to refactor the <code>DiscountCalculator</code> class.</p>"},{"location":"low-level-design/solid/srp/srp/","title":"Single Responsibility Principle Example","text":"<p>Single responsibility principle: a class should have one, and only one, reason to change. Each class should have one sole purpose (responsibility) and not be filled with excessive functionality. </p> Invalid Example C# <p>Invalid Example<pre><code>public class Product\n{\n    private string title;\n    private string type;\n    private decimal price;\n\n    public Product(string title, string type, decimal price)\n    {\n        this.title = title;\n        this.type = type;\n        this.price = price;\n    }\n\n    public void GetPrice()\n    {\n        Console.WriteLine(price);\n    }\n\n    public void GetTitle()\n    {\n        Console.WriteLine(title);\n    }\n\n    public void CalculateTax()\n    {\n        // Special equation to calculate tax based on product type\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Product toy = new Product(\"RC Car\", \"Toy\", 42.99M);\n        toy.GetPrice();\n        toy.GetTitle();\n        toy.CalculateTax();\n\n        Product drizzank = new Product(\"Wine\", \"Liquor\", 12.99M);\n        drizzank.GetPrice();\n        drizzank.GetTitle();\n        drizzank.CalculateTax();\n    }\n}\n</code></pre> Output<pre><code>42.99\nRC Car\n\"Calculate Tax for Toy Function...\"\n12.99\nWine\n\"Calculate Tax for Liquor Function...\"\n</code></pre></p> <p>This breaks the single responsibility principle because there are now multiple reasons for the class to be refactored: </p> <ol> <li> <p>If there needs to be changes made to the behavior of Product. For example what if we wanted to add year the product was created. </p> </li> <li> <p>If lawmakers change the taxes on a specific type of product.</p> </li> </ol> Valid Example C# Valid Example<pre><code>public class Product\n{\n    private string title;\n    private string type;\n    private decimal price;\n\n    public Product(string title, string type, decimal price)\n    {\n        this.title = title;\n        this.type = type;\n        this.price = price;\n    }\n\n    public void GetPrice()\n    {\n        Console.WriteLine(price);\n    }\n\n    public void GetTitle()\n    {\n        Console.WriteLine(title);\n    }\n}\n\npublic class TaxCalculator\n{\n    public static void CalculateTax(Product product)\n    {\n        // Special equation to calculate tax based on product type\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Product toy = new Product(\"RC Car\", \"Toy\", 42.99M);\n        toy.GetPrice();\n        toy.GetTitle();\n        TaxCalculator.CalculateTax(toy);\n\n        Product drizzank = new Product(\"Wine\", \"Liquor\", 12.99M);\n        drizzank.GetPrice();\n        drizzank.GetTitle();\n        TaxCalculator.CalculateTax(drizzank);\n    }\n\n}\n</code></pre> Output<pre><code>42.99\nRC Car\n\"Calculate Tax for Toy Function...\"\n12.99\nWine\n\"Calculate Tax for Liquor Function...\"\n</code></pre> <p>The creation of the class <code>TaxCalculator</code> fixes the issues with the invalid example. Now if lawmakers change the taxes on certain product types the <code>Product</code> class does not need to be touched. </p>"},{"location":"system-design/","title":"System Design","text":"<p>System design is the process of defining the architecture, interface, and data for a distributed software system.</p>"},{"location":"system-design/#high-level-diagram","title":"High Level Diagram","text":"<p>High Level Distributed System Diagram</p> <p> </p> <ol> <li>Client: user trying to access some software resource</li> <li>Domain Name Server (DNS): client sends requests with a URL, the DNS determines where to route that request. (Whats the IP address that contains the servers to handle request)</li> <li>Content Delivery Network (CDN): servers that handle global regions. Delivers static content for faster response times. </li> <li>Load Balancer: A server that acts as a reverse proxy. It helps distributes the load to multiple web servers. </li> <li>Web Sever: Actual server that contains all content and logic for a software resource (website)</li> <li>Database: Data server that stores all information</li> </ol>"},{"location":"system-design/basics/","title":"Scaling","text":"<p>Scalability: a systems ability to cope with increase load</p> <ul> <li>Scalability issue = system is fast for a single user, but slow under heavy load</li> </ul> <p>Scalable: when resources increase in a system, the increased performance from the resources should be proportional to the resources added. </p> <ul> <li>Adding additional database for redundancy (but not for performance) is an example of scaling.</li> </ul> <p>Vertical Scaling: add more resources to a single server/machine so it can handle more load</p> <ul> <li>Achieved by adding more ram, faster processor, or more disk space</li> <li>Will eventually reach a physical or technological limitation (making it a bad long-term solution)</li> </ul> <p>Horizontal Scaling: use multiple servers to build out a distributed topology. </p> <ul> <li>Utilize multiple cheap server/machines to handle more tasks/requests</li> <li>Issue: how do we distribute requests to multiple servers? (system design will solve this)</li> </ul>"},{"location":"system-design/basics/#speed","title":"Speed","text":"<p>Performance: a systems ability to perform a specific task</p> <ul> <li>A performance issue = system is slow for a single user</li> </ul> <p>Latency: time to perform some action or to produce some result.</p> <p>Throughput: number of such actions or results per unit of time. </p> <p>Latency VS Throughput: generally should aim for maximal throughput with acceptable latency</p>"},{"location":"system-design/cap/","title":"CAP Theorem","text":"<p>CAP Theorem: in a distributed system, only two of the following three can be provided.</p> <ul> <li>Consistency: every read receives the most recent write or an error.</li> <li>Availability: every request receives a response, without guarantee that it contains the most recent version of the information.</li> <li>Partition Tolerance: the system continues to operate despite arbitrary partitioning due to network failures.<ul> <li>A partition is when a network fails to deliver some message by losing them (eventual delivery or delay of a message is not a partition)</li> <li>Total partition is a period when no messages are delivered between two sets of node. A failed server/machine is not a total partition</li> </ul> </li> </ul> <p>Networks are not reliable failures will occur. Partitions must be tolerated in a distributed system. This means, in the real world, when designing a distributed system there are two options in relation to the CAP theorem: </p> <ol> <li>Consistency + Partition Tolerance</li> <li>Availability + Partition Tolerance</li> </ol>"},{"location":"system-design/cap/#consistency-partition-tolerance","title":"Consistency + Partition Tolerance","text":"<p>Consistency/Partition (CP): prioritizes returning consistent data or returning an error if its not available. Below are some potential features a system could have to make it CP tolerant. </p> <ul> <li>Timeout error: waits for response from partitioned nodes</li> <li>Turn off inconsistent nodes (return error based on why node is inconsistent)</li> </ul>"},{"location":"system-design/cap/#consistency-patterns","title":"Consistency Patterns","text":"<p>Within CP tolerant systems, the strictness of how consistent data has to be can vary. There are three different consistency patterns that helps determine how tolerant the CP system should be</p> <ol> <li> <p>Weak Consistency: After a write, reads may or may not see it</p> </li> <li> <p>Eventual Consistency: After a write, reads will eventually see it</p> </li> <li> <p>Strong Consistency: After a write, reads will see it</p> </li> </ol> Example - Mongo DB <p>MongoDB uses a single leader based architecture with multiple replicas. This means that data gets written to a main source and gets replicated to the replicas. </p> <p>Reading will reference this master database which means we will always get the correct data (strong consistency). </p> <p>The trade-off is when messages are lost, there is no way for the primary database to get it back, meaning we sacrificed availability. </p> <p>However, there are ways to configure MongoDB such that you sacrifice some consistency (evnetual consistency) to get some more availability. </p>"},{"location":"system-design/cap/#availability-partition-tolerance","title":"Availability + Partition Tolerance","text":"<p>Availability/Partition (AP): prioritizes always returning data regardless if the data is stale or up-to-date. Below are some potential features a system could have to make it AP tolerant.</p> <ul> <li>Return the most recent version data available (could be stale data)</li> <li>Systems could accept writes, but they may be processed at a later time (when partition is resolved)</li> </ul>"},{"location":"system-design/cap/#availability-patterns","title":"Availability Patterns","text":"<p>Like CP tolerant systems, the strictness on availability can vary as well. There are two main availability patterns that can be implemented in an AP tolerant system. </p> <ol> <li> <p>Fail-Over: design pattern that utilizes multiple nodes to prioritize maintaining uptime. There are two main approaches to fail-over design:</p> <ul> <li>Active-Passive (master-slave fail-over): <ul> <li>Two servers, active and passive</li> <li>Only active server handles traffic/requests</li> <li>Heartbeats are sent between active/passive server</li> <li>If heartbeat is interrupted (active server dies), the passive server takes over the active's IP address and resumes service</li> <li>Length of downtime determined by whether the passive server is already running hot (in standby) or cold (needs to be booted up)</li> </ul> </li> <li>Active-Active (master-master fail-over)<ul> <li>Both servers are managing traffic, spreading load between them</li> <li>If public-facing, DNS needs to know public IPs of both server</li> <li>If internal-facing, application logic needs to know about both servers</li> </ul> </li> </ul> </li> <li> <p>Replication: having redundant systems with the same copy of the data. If one fails, it is replaced by a copy</p> <ul> <li>topic further discussed in scaling database section</li> </ul> </li> </ol> Example - Cassandra DB <p>Cassandra has multiple database nodes that are connected in a ring (ring represents a data center). Each of these nodes have the ability to get read/written to. </p> <p>This means if one node goes down (or a partition occurs), another node can pick it up (high availibility). </p> <p>In the backend the nodes coordinate (gossiping) to coordinate the data they store. This is a trade-off lost of consistency since the nodes can have varying data at a given time. </p> <p>Again, like MongoDB, Cassandra can be configure to be more consistent by sacrificing some availbilty. </p>"},{"location":"system-design/cap/#quantifying-availability","title":"Quantifying Availability","text":"<p>Availability is often quantified by uptime (or downtime) as a percentage of time the service is available. Availability is measured by the number of 9s in the percentage.</p> <p>99.9% (Three 9s)</p> Duration Acceptable Downtime Downtime Per Year 8h 45m 57s Downtime Per Month 43m 49.7s Downtime Per Week 10m 4.8s Downtime Per Day 1m 26.4s <p>99.99% (Four 9s)</p> Duration Acceptable Downtime Downtime Per Year 52m 35.7s Downtime Per Month 4m 23s Downtime Per Week 1m 5s Downtime Per Day 8.6s"},{"location":"system-design/cap/#calculating-availability","title":"Calculating Availability","text":"<p>Calculating availability of in sequence components</p> <ul> <li>Availability (Total) = Availability (Server 1) * Availability (Server 2)</li> <li>Overall decrease if in sequence</li> </ul> <p>Calculating availability of in parallel components</p> <ul> <li>Availability (Total) = 1 - (1 - Availability (Server 1)) * (1 - Availability (Server 2))</li> <li>Overall increase if in parallel</li> </ul>"},{"location":"system-design/cap/#resources","title":"Resources","text":"<p> CAP Example Video</p> <p> CAP</p> <p> MongoDB vs CassandraDB</p>"},{"location":"system-design/scaling-databases/","title":"Scaling Databases","text":"<p>Review the following topics before delving into this section:</p> <ul> <li>Relational Databases</li> <li>Non-Relational Databases</li> </ul> <p>There are two approaches to scaling up databases (these can be done in unison)</p> <ol> <li>Additional redundancy (for better uptime, and preventing the loss of data)</li> <li>Performance boost (faster writes and handling more loads)</li> </ol> <p>Before we go into scaling techniques we will go over transactional models</p>"},{"location":"system-design/scaling-databases/acid-vs-base/","title":"Transaction Models","text":"<p>The CAP Theorem states it is impossible to achieve both consistency and availability in a partition tolerant distributed system. Therefore, when it comes to database transaction models, there are two primary models, one that prioritizes consistency and one for availability. </p>"},{"location":"system-design/scaling-databases/acid-vs-base/#acid-model","title":"ACID Model","text":"<p>The ACID model ensures that transactions are always consistent. Due to the emphasis on consistency, ACID model databases are usually used for databases with strong constraints such as relational databases. Although NoSQL database can be somewhat ACID compliant, the ACID model goes against the NoSQL approach to database design. </p> <p>ACID is an acronym, where each word represents a quality of the ACID model.</p>"},{"location":"system-design/scaling-databases/acid-vs-base/#atomicity","title":"Atomicity:","text":"<p>Atomic: each transaction is either properly carried out or the process halts and the database reverts back to the state before the transaction started. Ensures all data in the database is valid.</p> <ul> <li>Basic: read and writes either finish completely, or abandoned altogether.</li> <li>Important for handling crashes or outages.</li> </ul>"},{"location":"system-design/scaling-databases/acid-vs-base/#consistency","title":"Consistency","text":"<p>Consistent: a processed transaction will never endanger the data integrity of the database.</p> <ul> <li>Basic: Does not violate integrity of the database.</li> <li>Ensures if something being added will compromise the database structure, it will get aborted</li> <li>Helps maintain schema if there is one</li> <li>This could also be used as maintaining constraints. EX. Bank Withdrawal database shouldn't allow negative account balances. </li> </ul>"},{"location":"system-design/scaling-databases/acid-vs-base/#isolation","title":"Isolation","text":"<p>Isolated: transactions cannot compromise the integrity of other transactions by interacting with them while they are still in progress.</p> <ul> <li>Basic: read or writes on database will not be impacted by other read or writes of separate transactions on the same database</li> <li>Optimistic transaction schema: assumes two transactions will most likely not effect each other and lets both run. However, if conflict occur, it will abort both and make both retry again. </li> <li>Pessimistic transaction schema: locks down resources and forms a queue for all transactions. This means less abort and retries, but possibly longer wait times for transactions. </li> </ul>"},{"location":"system-design/scaling-databases/acid-vs-base/#durability","title":"Durability","text":"<p>Durable: the data related to the completed transaction will persist even in the cases of network or power outages. If a transaction fails, it will not impact the manipulated data.</p> <ul> <li>Basic: changes in database made will be permanent in the database</li> <li>Ensures data will not be corrupted by outages, crashed, etc...</li> <li>Achieved through changelogs that are referenced when databases are restarted</li> </ul>"},{"location":"system-design/scaling-databases/acid-vs-base/#base-model","title":"BASE Model","text":"<p>The BASE model prioritizes availability. It was created to reflect the flexible and fluid properties of NoSQL databases. </p> <p>Like ACID, BASE is also an acronym that is self describing of the model itself. </p>"},{"location":"system-design/scaling-databases/acid-vs-base/#basically-available-ba","title":"Basically Available (BA)","text":"<p>Basically available: rather than enforcing immediate consistency, BASE-modelled NoSQL databases will ensure availability of data by spreading and replicating it across the nodes of the database cluster. </p> <ul> <li>There will be a response to every requests (even if response is a system failure, or stale data)</li> </ul>"},{"location":"system-design/scaling-databases/acid-vs-base/#soft-state","title":"Soft State","text":"<p>Soft state: due to lack of immediate consistency, data values may change over time. Soft state breaks away from the concept of databases enforcing its own consistency and delegates that responsibility to developers. </p> <ul> <li>Soft state is due to the eventual consistency model, where the database doesn't care if transactions are consistent</li> </ul>"},{"location":"system-design/scaling-databases/acid-vs-base/#eventually-consistent","title":"Eventually Consistent","text":"<p>Eventually Consistent: even though it doesn't enforce immediate consistency, it will eventually achieve it. Until it does, data reads are still possible (although may be stale)</p> <ul> <li>In the case of NoSQL, copies of the database are on multiple servers. If a write transaction just occurred it may not be available on all servers (needs to clone to all server). However, it eventually will be cloned, and thus consistent.</li> </ul>"},{"location":"system-design/scaling-databases/acid-vs-base/#resources","title":"Resources","text":"<p>ACID Explained</p> <p>ACID VS BASE</p>"},{"location":"system-design/scaling-databases/scaling-techniques/","title":"Scaling Techniques","text":"<p>There are many techniques to scale a database. The last being for relational databases only</p> <ul> <li>Master-Slave Replication</li> <li>Master-Master Replication</li> <li>Federation</li> <li>Sharding</li> <li>Denormalization</li> <li>SQL Tuning (RDB)</li> </ul>"},{"location":"system-design/scaling-databases/scaling-techniques/other/","title":"Other Scaling Techniques","text":""},{"location":"system-design/scaling-databases/scaling-techniques/other/#denormalization","title":"Denormalization","text":"<p>Denormalization: denormalize a previously normalized database in efforts to improve the read performance of a database.</p> <ul> <li>Add redundant data to multiple tables (avoids expensive joins)</li> <li>Done when performance/scalability is a main concern</li> <li>In most systems reads outweigh writes 100:1 or even 1000:1</li> </ul> <p>Disadvantages of Denormalization</p> <ul> <li>Data is duplicated</li> <li>Constraints can help redundant copies of information stay in sync, which increases complexity of database design</li> <li>Denormalized database under heavy write load might perform worse than its normalized counterpart</li> </ul>"},{"location":"system-design/scaling-databases/scaling-techniques/other/#sql-tuning-rdb-only","title":"SQL Tuning (RDB Only)","text":"<p>SQL Tuning: is the process of enhancing SQL queries to speed up the performance of the server. This is a vast topic with a lot of different techniques/resources. This section will lightly go over some tips to speed up queries.</p> <p>Benchmark and Profile are important to do to simulate and uncover bottlenecks.</p> <ul> <li>Benchmark: simulate high-load situations (tools usually exists for this)</li> <li>Profile: enable tools such as the slow query log to help track performance issues</li> </ul> <p>General Optimizations:</p> <ul> <li>Tighten up schema:<ul> <li>MySQL dumps to disk in contiguous blocks for fast access</li> <li>Use <code>CHAR</code> instead of <code>VARCHAR</code> for fixed-length fields<ul> <li><code>CHAR</code> allows for fast, random access, whereas</li> <li><code>VARCHAR</code> must find the end of a string before moving onto next one</li> </ul> </li> <li>Use <code>TEXT</code> for large blocks of text (blog posts)<ul> <li>Allows for boolean searches</li> <li>Use <code>TEXT</code> field results in storing a pointer on disk that is used to locate the text block</li> </ul> </li> <li>Use <code>INT</code> for numbers up to 2^32 or 4 billion</li> <li>Use <code>DECIMAL</code> for currency to avoid floating point representation errors</li> <li>Avoid storing large <code>BLOBS</code>, store the location of where to get object instead</li> <li><code>VARCHAR(255)</code> is the largest number of characters that can be counted in an 8 bit number, often maximizing the use of a byte in some RDBMS.</li> <li>Set <code>NOT NULL</code> constraint where applicable (improves search performance)</li> </ul> </li> <li>Use good indices<ul> <li>Columns that you are querying could be faster with indices</li> <li>Indices are usually represented as self-balancing B-tree that keeps data stored and allow searches, sequential access, insertions, and deletions in logarithmic time</li> <li>Placing an index can keep the data in memory, requiring more space</li> <li>Writes could be slow since the index also needs to be updated</li> <li>When loading large amounts of data, it might be faster to disable indices, load the data, then rebuild the indices</li> </ul> </li> <li>Avoid expensive joins (denormalize)</li> <li>Partition table</li> <li>Tune the query cache</li> </ul>"},{"location":"system-design/scaling-databases/scaling-techniques/partition/","title":"Partition","text":""},{"location":"system-design/scaling-databases/scaling-techniques/partition/#federation","title":"Federation","text":"<p>Federation (functional partitioning) is a technique in which we split up a single database into multiple databases based on the characteristic of the data that goes into each individual database. </p> Federation Diagram <p> </p> <p>The single bank database gets split up based on business logic. The databases themselves can act independently from others. </p> <p>Advantages of Federation:</p> <ul> <li>Less read and write traffic to each database and therefore less replication lag</li> <li>Smaller databases, results in more data that can fit in memory, which in turn results in more cache hits due to improved cache locality</li> <li>No centralized database (can write in parallel, increasing throughput)</li> <li>Horizontal scaling (adding more servers)</li> </ul> <p>Disadvantages of Federation:</p> <ul> <li>Federation is not effective if your schema requires huge functions or tables</li> <li>Need to update application logic to determine which database to read/write to</li> <li>Joining data from two databases is more complex with a server link SQL command</li> <li>Federation adds more hardware and additional complexity</li> </ul>"},{"location":"system-design/scaling-databases/scaling-techniques/partition/#sharding","title":"Sharding","text":"<p>Sharding distributes data across different databases such that each database can only manage a subset of the data. Sounds similar to federation but they're different, read shard VS federation for more clarification</p> Sharding Diagram <p> </p> <p>The single database has its data split up generically into multiple data servers. Each server maintians the same schema.</p> <p>Advantages of Sharding: </p> <ul> <li>Results in less read and write traffic</li> <li>Less replication, more cache hits</li> <li>Index size reduced, faster queries (on individual shards)</li> <li>If one shard goes down, other shards are operational</li> <li>Allow for parallel writes (throughput)</li> </ul> <p>Disadvantages of Sharding:</p> <ul> <li>Need to update application logic (could result in complex SQL queries)</li> <li>Data distribution can become lopsided!<ul> <li>Example: one shard could have more active users (uneven server load)</li> <li>Rebalancing the load adds additional complexity</li> <li>Solution: consistent hashing</li> </ul> </li> <li>Joining data from multiple shards is more complex</li> <li>Sharding adds more hardware and additional complexity</li> </ul>"},{"location":"system-design/scaling-databases/scaling-techniques/partition/#consistent-hashing","title":"Consistent Hashing","text":"<p>Hashing is an important part of sharding. It works by passing a chunk of data to a hashing function, which provides a hash value. This hash value now represents a chunk (or shard) of data. </p> <p>Below are two ways where shards are distributed to servers. For both of these methods, what needs to be considered is how does a failed/added server effect the distribution technique?</p> <p>Trivial Solution</p> Trivial Sharding Hashing <p></p> <p> </p> <p></p> <ol> <li>Given data, split it up into data chunks</li> <li>For each data chunk, run it through a hash function to assign a hash value to each chunk</li> <li>Store hash values into a hash array. </li> </ol> Trivial Sharding Distribution <p></p> <p> </p> <p></p> <ol> <li>Trivial solution uses modulo to evenly assign chunks to N servers</li> <li>If number of server changes (failed server or new server added), need to redo modulo</li> <li>Redoing modulo results in a lot of reshuffled hash values (not very good)</li> </ol> <p>Consistent Hashing Solution </p> Sharding Consistent Hashing <p></p> <p> </p> <p></p> <ul> <li>Hashes all the data AND the servers we have available and stores it on a table</li> <li>Connect the table from beginning to end so it forms a ring</li> <li>Whenever a server is added/removed, we add/remove the corresponding entry on the hash table</li> <li>Now, every data object behind that entry on the hash table will be shifted to the next visible server object on the hash table.</li> <li>This ensures minimal shifting of data objects whenever servers are adjusted.</li> </ul>"},{"location":"system-design/scaling-databases/scaling-techniques/partition/#sharding-vs-federation","title":"Sharding VS Federation","text":"<p>I am unsure what the difference is but this is my interpretation.</p> <ul> <li>Federation: data gets split up based on the characteristics of the data. Since data is split based on how data is used, we can have each database contain different schemas. </li> <li>Sharding: data gets split up generically. Since the data is split up generically, all databases that stores a shard needs to maintain the same schema. </li> </ul>"},{"location":"system-design/scaling-databases/scaling-techniques/replication/","title":"Replication","text":""},{"location":"system-design/scaling-databases/scaling-techniques/replication/#master-slave-replication","title":"Master-Slave Replication","text":"<p>In the master-slave replication design, we have a master server, and multiple slave servers.</p> <ul> <li>The master server does the following:<ul> <li>Serves both reads and writes</li> <li>Replicates writes to one or more slaves</li> </ul> </li> <li>The slave server does the following:<ul> <li>Serves only reads</li> <li>Replicate to additional slaves (in a tree like fashion)</li> </ul> </li> <li>If master goes offline, a slave is promoted to master, or a new master is provisioned</li> </ul> <p>Disadvantages of Master-Slave:</p> <ul> <li>Additional logic is needed to promote slave to a master</li> <li>Includes Disadvantages of Replication</li> </ul>"},{"location":"system-design/scaling-databases/scaling-techniques/replication/#master-master-replication","title":"Master-Master Replication","text":"<p>In the master-master replication design, we have multiple master servers. Both master servers read and write and coordinate with each other on writes. If either goes down, the system can continue to operate with both read and writes.</p> <p>Disadvantages of Master-Master:</p> <ul> <li>Need a load balancer OR change application logic to determine where to write</li> <li>Most master-master systems are either loosely consistent (violates ACID) or have increased write latency due to synchronization</li> <li>Conflict resolution comes into play as more write nodes are added and latency increases</li> <li>Includes Disadvantages of Replication</li> </ul>"},{"location":"system-design/scaling-databases/scaling-techniques/replication/#replication-master-master-master-slave","title":"Replication Master-Master + Master-Slave","text":"<p>It is common to combine the two replication techiniques so that a distributed system can handle higher load and have data redundancies. Below is an example of a system that uses both techniques</p> <p>Replication Diagram</p> <p></p> <p> </p> <p></p>"},{"location":"system-design/scaling-databases/scaling-techniques/replication/#disadvantages-of-replication","title":"Disadvantages of Replication","text":"<ul> <li>Potential for loss of data if master fails before newly written data is replicated to other nodes</li> <li>Writes are replayed to the read replicas (if there are a lot of writes, system can get bogged down)</li> <li>Replication lag: the more read slaves, the more you have to replicate</li> <li>On some systems, writes are parallelized but reads are sequential</li> <li>Replication add mores hardware/complexity</li> </ul>"}]}